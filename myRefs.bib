,l% !TeX root = main.tex
%%%%%%%%% STRING FORMATS %%%%%%%%%%%%%%%
@string{acm =   "ACM Press"}
@string{els = "Elsevier"}
@string{cam = "Cambridge University Press"}
@string{api = "Academic Press, Inc"}
@string{cacm =  "Communications of the ACM"}
@string{jacm =  "Journal of the ACM"}
@string{iac = "Information and Computation"}
@string{tsi = "Technique et science informatique"}
@string{sv =    "Springer-Verlag"}
@string{lncs =  "Lecture Notes in Computer Science"}
@string{lnai =  "Lecture Notes in Artificial Intelligence"}
@string{sigplan = "ACM SIGPLAN Notices"}
@string{kap = "Kluwer Academic Publishers"}
@string{ieee = "IEEE Computer Society Press"}
@string{toplas = "ACM Transactions on Programming Languages and Systems"}
@string{tosem = "ACM Transactions on Software Engineering and Methodology"}
@string{taas = "ACM Transactions on Autonomous and Adaptive Systems"}
@string{taosd = "Transactions on Aspect-Oriented Software Development"}
@string{tse = "IEEE Transactions on Software Engineering"}
@string{isoft = "IEEE Software"}
@string{ietsoft = "IET Software"}
@string{tcs = "Theoretical Computer Science"}
@string{wiley = "Wiley \& Sons"}
@string{spe = "Software---Practice and Experience"}
@string{ccpe = "Concurrency and Computation---Practice and Experience"}
@string{scp = "Science of Computer Programming"}
@string{mit = "MIT Press"}
@string{jucs = "Journal of Universal Computer Science"}
@string{clss = "Journal of Computer Languages, Systems and Structures"}
@string{hosc = "Higher-Order and Sympolic Computation"}
@string{jfp = "Journal of Functional Programming"}
@string{sacs = "Scientific Annals of Computer Science"}
@string{jot = "Journal of Object Technology"}
@string{puc = "Personal and Ubiquitous Computing"}
@string{emse = "Empirical Software Engineering"}
@string{csur = "ACM Computing Surveys"}
@string{ap = "Academic Press, Inc."}
@string{aw = "Addison-Wesley"}
@string{entcs = "Electronic Notes in Theoretical Computer Science"}
@string{eptcs = "Electronic Proceedings in Theoretical Computer Science"}
@string{lmcs = "Logical Methods in Computer Science"}
@string{oxford = "Oxford University Press"}
@string{dagstuhl = "Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik"}
@string{lipics = "Leibniz International Proceedings in Informatics (LIPIcs)"}
@string{jcs = "Journal of Computer Security"}
@string{ios = "IOS Press"}
@string{dist = "Distributed Computing"}
@string{pacmpl = "Proceedings of the ACM on Programming Languages"}
@string{mscs = "Mathematical Structures in Computer Science"}
@string{nhp = "North-Holland Pub. Co"}

@InProceedings{dynamicDependent,
  author          = "Ou, Xinming and Tan, Gang and Mandelbaum, Yitzhak and
                  Walker, David",
  editor          = "Levy, Jean-Jacques and Mayr, Ernst W. and Mitchell, John
                  C.",
  title           = "Dynamic Typing with Dependent Types",
  booktitle       = "Exploring New Frontiers of Theoretical Informatics",
  year            = 2004,
  publisher       = "Springer US",
  address         = "Boston, MA",
  pages           = "437--450",
  abstract        = "Dependent type systems are promising tools programmers can
                  use to increase the reliability and security of their
                  programs. Unfortunately, dependently-typed programming
                  languages require programmers to annotate their programs with
                  many typing specifications to help guide the type checker.
                  This paper shows how to make the process of programming with
                  dependent types more palatable by defining a language in which
                  programmers have fine-grained control over the trade-off
                  between the number of dependent typing annotations they must
                  place on programs and the degree of compile-time safety. More
                  specifically, certain program fragments are marked dependent,
                  in which case the programmer annotates them in detail and a
                  dependent type checker verifies them at compile time. Other
                  fragments are marked simple, in which case they may be
                  annotation-free and dependent constraints are verified at run
                  time.",
  isbn            = "978-1-4020-8141-5",
  DOI = {https://doi.org/10.1007/1-4020-8141-3_34}
}

@InProceedings{10.1007/11547662_16,
  author          = "Kodumal, John and Aiken, Alex",
  editor          = "Hankin, Chris and Siveroni, Igor",
  title           = "Banshee: A Scalable Constraint-Based Analysis Toolkit",
  booktitle       = "Static Analysis",
  year            = 2005,
  publisher       = "Springer Berlin Heidelberg",
  address         = "Berlin, Heidelberg",
  pages           = "218--234",
  abstract        = "We introduce Banshee, a toolkit for constructing
                  constraint-based analyses. Banshee's novel features include a
                  code generator for creating customized constraint resolution
                  engines, incremental analysis based on backtracking, and fast
                  persistence. These features make Banshee useful as a
                  foundation for production program analyses.",
  isbn            = "978-3-540-31971-9"
}

@InProceedings{10.1007/3-540-58601-6_107,
  author          = "Heintze, Nevin and Jaffar, Joxan",
  editor          = "Borning, Alan",
  title           = "Set constraints and set-based analysis",
  booktitle       = "Principles and Practice of Constraint Programming",
  year            = 1994,
  publisher       = "Springer Berlin Heidelberg",
  address         = "Berlin, Heidelberg",
  pages           = "281--298",
  abstract        = "The calculus of set constraints was presented, and its
                  history of basic results and applications briefly described.
                  The approach of set-based analysis was then presented in an
                  informal style, with a focus on the breadth of applicability
                  of the technique. The relationship between set constraints and
                  set-based analysis is roughly that the approximation of a
                  program by ignoring inter-variable dependencies can be
                  captured by set constraints. It was then argued that set-based
                  analysis can provide accurate and efficient program analysis.",
  isbn            = "978-3-540-49032-6"
}

@InProceedings{10.1007/3-540-63237-9_19,
  author          = "Boquist, Urban and Johnsson, Thomas",
  editor          = "Kluge, Werner",
  title           = "The GRIN project: A highly optimising back end for lazy
                  functional languages",
  booktitle       = "Implementation of Functional Languages",
  year            = 1997,
  publisher       = "Springer Berlin Heidelberg",
  address         = "Berlin, Heidelberg",
  pages           = "58--84",
  abstract        = "Low level optimisations from conventional compiler
                  technology often give very poor results when applied to code
                  from lazy functional languages, mainly because of the
                  completely different structure of the code, unknown control
                  flow, etc. A novel approach to compiling laziness is needed.",
  isbn            = "978-3-540-69239-3"
}

@InProceedings{10.1007/978-3-319-12736-1_6,
  author          = "Palmer, Zachary and Menon, Pottayil Harisanker and
                  Rozenshteyn, Alexander and Smith, Scott",
  editor          = "Garrigue, Jacques",
  title           = "Types for Flexible Objects",
  booktitle       = "Programming Languages and Systems",
  year            = 2014,
  publisher       = "Springer International Publishing",
  address         = "Cham",
  pages           = "99--119",
  abstract        = "Scripting languages are popular in part due to their
                  extremely flexible objects. Features such as dynamic
                  extension, mixins, and first-class messages improve
                  programmability and lead to concise code. But attempts to
                  statically type these features have met with limited success.
                  Here we present TinyBang, a small typed language in which
                  flexible object operations can be encoded. We illustrate this
                  flexibility by solving an open problem in OO literature: we
                  give an encoding where objects can be extended after being
                  messaged without compromising the expressiveness of subtyping.
                  TinyBang's subtype constraint system ensures that all types
                  are completely inferred; there are no data declarations or
                  type annotations. We formalize TinyBang and prove the type
                  system is sound and decidable; all examples in the paper run
                  in our most recent implementation.",
  isbn            = "978-3-319-12736-1"
}

@InProceedings{10.1007/978-3-319-19797-5_13,
  author          = "McBride, Conor",
  editor          = "Hinze, Ralf and Voigtl{\"a}nder, Janis",
  title           = "Turing-Completeness Totally Free",
  booktitle       = "Mathematics of Program Construction",
  year            = 2015,
  publisher       = "Springer International Publishing",
  address         = "Cham",
  pages           = "257--275",
  abstract        = "In this paper, I show that general recursive definitions
                  can be represented in the free monad which supports the
                  `effect' of making a recursive call, without saying how these
                  calls should be executed. Diverse semantics can be given
                  within a total framework by suitable monad morphisms. The
                  Bove-Capretta construction of the domain of a general
                  recursive function can be presented datatype-generically as an
                  instance of this technique. The paper is literate Agda, but
                  its key ideas are more broadly transferable.",
  isbn            = "978-3-319-19797-5"
}

@InProceedings{10.1007/978-3-319-19797-5_13,
  author          = "McBride, Conor",
  editor          = "Hinze, Ralf and Voigtl{\"a}nder, Janis",
  title           = "Turing-Completeness Totally Free",
  booktitle       = "Mathematics of Program Construction",
  year            = 2015,
  publisher       = "Springer International Publishing",
  address         = "Cham",
  pages           = "257--275",
  abstract        = "In this paper, I show that general recursive definitions
                  can be represented in the free monad which supports the
                  `effect' of making a recursive call, without saying how these
                  calls should be executed. Diverse semantics can be given
                  within a total framework by suitable monad morphisms. The
                  Bove-Capretta construction of the domain of a general
                  recursive function can be presented datatype-generically as an
                  instance of this technique. The paper is literate Agda, but
                  its key ideas are more broadly transferable.",
  isbn            = "978-3-319-19797-5"
}

@InProceedings{10.1007/978-3-319-21401-6_26,
  author          = "de Moura, Leonardo and Kong, Soonho and Avigad, Jeremy and
                  van Doorn, Floris and von Raumer, Jakob",
  editor          = "Felty, Amy P. and Middeldorp, Aart",
  title           = "The Lean Theorem Prover (System Description)",
  booktitle       = "Automated Deduction - CADE-25",
  year            = 2015,
  publisher       = "Springer International Publishing",
  address         = "Cham",
  pages           = "378--388",
  abstract        = "Lean is a new open source theorem prover being developed at
                  Microsoft Research and Carnegie Mellon University, with a
                  small trusted kernel based on dependent type theory. It aims
                  to bridge the gap between interactive and automated theorem
                  proving, by situating automated tools and methods in a
                  framework that supports user interaction and the construction
                  of fully specified axiomatic proofs. Lean is an ongoing and
                  long-term effort, but it already provides many useful
                  components, integrated development environments, and a rich
                  API which can be used to embed it into other systems. It is
                  currently being used to formalize category theory, homotopy
                  type theory, and abstract algebra. We describe the project
                  goals, system architecture, and main features, and we discuss
                  applications and continuing work.",
  isbn            = "978-3-319-21401-6"
}

@InProceedings{10.1007/978-3-540-24849-1_25,
  author          = "Xi, Hongwei",
  editor          = "Berardi, Stefano and Coppo, Mario and Damiani, Ferruccio",
  title           = "Applied Type System",
  booktitle       = "Types for Proofs and Programs",
  year            = 2004,
  publisher       = "Springer Berlin Heidelberg",
  address         = "Berlin, Heidelberg",
  pages           = "394--408",
  abstract        = "The framework Pure Type System
                  ({\$}{\backslash}mathcal{\{}PTS{\}}{\$}) offers a simple and
                  general approach to designing and formalizing type systems.
                  However, in the presence of dependent types, there often exist
                  some acute problems that make it difficult for
                  {\$}{\backslash}mathcal{\{}PTS{\}}{\$}to accommodate many
                  common realistic programming features such as general
                  recursion, recursive types, effects (e.g., exceptions,
                  references, input/output), etc. In this paper, we propose a
                  new framework Applied Type System
                  ({\$}{\backslash}mathcal{\{}ATS{\}}{\$}) to allow for
                  designing and formalizing type systems that can readily
                  support common realistic programming features. The key salient
                  feature of {\$}{\backslash}mathcal{\{}ATS{\}}{\$}lies in a
                  complete separation between statics, in which types are formed
                  and reasoned about, and dynamics, in which programs are
                  constructed and evaluated. With this separation, it is no
                  longer possible for a program to occur in a type as is
                  otherwise allowed in {\$}{\backslash}mathcal{\{}PTS{\}}{\$}.
                  We present not only a formal development of
                  {\$}{\backslash}mathcal{\{}ATS{\}}{\$}but also mention some
                  examples in support of using
                  {\$}{\backslash}mathcal{\{}ATS{\}}{\$}as a framework to form
                  type systems for practical programming.",
  isbn            = "978-3-540-24849-1"
}


@inproceedings{blameSubtyping,
author = {Wadler, Philip and Findler, Robert Bruce},
title = {Well-Typed Programs Can't Be Blamed},
year = {2009},
isbn = {9783642005893},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
url = {https://doi.org/10.1007/978-3-642-00590-9_1},
doi = {10.1007/978-3-642-00590-9_1},
abstract = {We introduce the <em>blame calculus</em> , which adds the notion of blame from Findler and Felleisen's <em>contracts</em> to a system similar to Siek and Taha's <em>gradual types</em> and Flanagan's <em>hybrid types</em> . We characterise where positive and negative blame can arise by decomposing the usual notion of subtype into positive and negative subtypes, and show that these recombine to yield naive subtypes. Naive subtypes previously appeared in type systems that are unsound, but we believe this is the first time naive subtypes play a role in establishing type soundness.},
booktitle = {Proceedings of the 18th European Symposium on Programming Languages and Systems: Held as Part of the Joint European Conferences on Theory and Practice of Software, ETAPS 2009},
pages = {1–16},
numpages = {16},
location = {York, UK},
series = {ESOP '09}
}


@InProceedings{10.1007/978-3-662-46669-8_18,
  author          = "Siek, Jeremy G. and Vitousek, Michael M. and Cimini, Matteo
                  and Tobin-Hochstadt, Sam and Garcia, Ronald",
  editor          = "Vitek, Jan",
  title           = "Monotonic References for Efficient Gradual Typing",
  booktitle       = "Programming Languages and Systems",
  year            = 2015,
  publisher       = "Springer Berlin Heidelberg",
  address         = "Berlin, Heidelberg",
  pages           = "432--456",
  abstract        = "Gradual typing enables both static and dynamic typing in
                  the same program and makes it convenient to migrate code
                  regions between the two typing disciplines. One goal of
                  gradual typing is to provide all the benefits of static
                  typing, such as efficiency, in statically-typed regions.
                  However, this goal is elusive: the standard approach to
                  mutable references imposes run-time overhead in
                  statically-typed regions and alternative approaches are too
                  conservative, either statically or at run-time. In this paper
                  we present a new semantics called monotonic references which
                  imposes none of the run-time overhead of dynamic typing in
                  statically typed regions. With this design, casting a
                  reference may cause a heap cell to become more statically
                  typed (but not less). Retaining type safety is challenging
                  with strong updates to the heap. Nevertheless, we have a
                  mechanized proof of type safety. Further, we present blame
                  tracking for monotonic references and prove a blame theorem.",
  isbn            = "978-3-662-46669-8"
}

@InProceedings{10.1007/978-3-662-49630-5_2,
  author          = "Bizjak, Ale{\v{s}} and Grathwohl, Hans Bugge and Clouston,
                  Ranald and M{\o}gelberg, Rasmus E. and Birkedal, Lars",
  editor          = "Jacobs, Bart and L{\"o}ding, Christof",
  title           = "Guarded Dependent Type Theory with Coinductive Types",
  booktitle       = "Foundations of Software Science and Computation Structures",
  year            = 2016,
  publisher       = "Springer Berlin Heidelberg",
  address         = "Berlin, Heidelberg",
  pages           = "20--35",
  abstract        = "We present guarded dependent type theory,
                  {\$}{\$}{\backslash}mathsf {\{}gDTT{\}}{\$}{\$}gDTT, an
                  extensional dependent type theory with a `later' modality and
                  clock quantifiers for programming and proving with guarded
                  recursive and coinductive types. The later modality is used to
                  ensure the productivity of recursive definitions in a modular,
                  type based, way. Clock quantifiers are used for controlled
                  elimination of the later modality and for encoding coinductive
                  types using guarded recursive types. Key to the development of
                  {\$}{\$}{\backslash}mathsf {\{}gDTT{\}}{\$}{\$}gDTTare novel
                  type and term formers involving what we call `delayed
                  substitutions'. These generalise the applicative functor rules
                  for the later modality considered in earlier work, and are
                  crucial for programming and proving with dependent types. We
                  show soundness of the type theory with respect to a
                  denotational model.",
  isbn            = "978-3-662-49630-5"
}

@InProceedings{10.1007/BFb0032737,
  author          = "F{\"a}hndrich, Manuel and Aiken, Alexander",
  editor          = "Van Hentenryck, Pascal",
  title           = "Program analysis using mixed term and set constraints",
  booktitle       = "Static Analysis",
  year            = 1997,
  publisher       = "Springer Berlin Heidelberg",
  address         = "Berlin, Heidelberg",
  pages           = "114--126",
  abstract        = "There is a tension in program analysis between precision
                  and efficiency. In constraint-based program analysis, at one
                  extreme methods based on unification of equality constraints
                  over terms are very fast but often imprecise. At the other
                  extreme, methods based on the resolution of inclusion
                  constraints over set expressions are quite precise, but are
                  often inefficient in practice. We describe a parameterized
                  framework for constraint-based program analyses that allows
                  the analysis designer to embed terms and set expressions
                  within each other. Constraints over these mixed expressions
                  are partially between equality and inclusion, which enables an
                  entire spectrum of program analyses with varying degrees of
                  precision and efficiency to be expressed. We also show that
                  there are interesting analyses that take advantage of this
                  mixture. In particular, we report on the design and
                  implementation of an uncaught exception analysis for core ML.
                  Our results show that the analysis approaches the efficiency
                  of algorithm W.",
  isbn            = "978-3-540-69576-9"
}

@InProceedings{10.1007/BFb0055513,
  author          = "Aiken, Alexander and F{\"a}hndrich, Manuel and Foster,
                  Jeffrey S. and Su, Zhendong",
  editor          = "Leroy, Xavier and Ohori, Atsushi",
  title           = "A toolkit for constructing type- and constraint-based
                  program analyses",
  booktitle       = "Types in Compilation",
  year            = 1998,
  publisher       = "Springer Berlin Heidelberg",
  address         = "Berlin, Heidelberg",
  pages           = "78--96",
  abstract        = "BANE (the Berkeley Analysis Engine) is a publicly available
                  toolkit for constructing type- and constraint-based program
                  analyses. We describe the goals of the project, the rationale
                  for BANE's overall design, some examples coded in BANE, and
                  briefly compare BANE with other program analysis frameworks.",
  isbn            = "978-3-540-68308-7"
}

@article{10.1145/1543134.1411293,
  author          = {Mitchell, Neil and Runciman, Colin},
  title           = {Not All Patterns, but Enough: An Automatic Verifier for
                  Partial but Sufficient Pattern Matching},
  year            = 2008,
  issue_date      = {January 2009},
  publisher       = {Association for Computing Machinery},
  address         = {New York, NY, USA},
  volume          = 44,
  number          = 2,
  issn            = {0362-1340},
  url             = {https://doi.org/10.1145/1543134.1411293},
  doi             = {10.1145/1543134.1411293},
  journal         = {SIGPLAN Not.},
  month           = sep,
  pages           = {49–60},
  numpages        = 12,
  keywords        = {automatic verification, haskell, functional programming,
                  preconditions, pattern-match errors}
}

@inproceedings{10.1145/2034773.2034796,
  author          = {Devriese, Dominique and Piessens, Frank},
  title           = {On the Bright Side of Type Classes: Instance Arguments in
                  Agda},
  year            = 2011,
  isbn            = 9781450308656,
  publisher       = {Association for Computing Machinery},
  address         = {New York, NY, USA},
  url             = {https://doi.org/10.1145/2034773.2034796},
  doi             = {10.1145/2034773.2034796},
  booktitle       = {Proceedings of the 16th ACM SIGPLAN International
                  Conference on Functional Programming},
  pages           = {143–155},
  numpages        = 13,
  keywords        = {ad hoc polymorphism, type classes, agda, instance
                  arguments},
  location        = {Tokyo, Japan},
  series          = {ICFP ’11}
}

@inproceedings{10.1145/2500365.2500597,
  author          = {Atkey, Robert and McBride, Conor},
  title           = {Productive Coprogramming with Guarded Recursion},
  year            = 2013,
  isbn            = 9781450323260,
  publisher       = {Association for Computing Machinery},
  address         = {New York, NY, USA},
  url             = {https://doi.org/10.1145/2500365.2500597},
  doi             = {10.1145/2500365.2500597},
  abstract        = {Total functional programming offers the beguiling vision
                  that, just by virtue of the compiler accepting a program, we
                  are guaranteed that it will always terminate. In the case of
                  programs that are not intended to terminate, e.g., servers, we
                  are guaranteed that programs will always be productive.
                  Productivity means that, even if a program generates an
                  infinite amount of data, each piece will be generated in
                  finite time. The theoretical underpinning for productive
                  programming with infinite output is provided by the category
                  theoretic notion of final coalgebras. Hence, we speak of
                  coprogramming with non-well-founded codata, as a dual to
                  programming with well-founded data like finite lists and
                  trees.Systems that offer facilities for productive
                  coprogramming, such as the proof assistants Coq and Agda,
                  currently do so through syntactic guardedness checkers.
                  Syntactic guardedness checkers ensure that all self-recursive
                  calls are guarded by a use of a constructor. Such a check
                  ensures productivity. Unfortunately, these syntactic checks
                  are not compositional, and severely complicate
                  coprogramming.Guarded recursion, originally due to Nakano, is
                  tantalising as a basis for a flexible and compositional
                  type-based approach to coprogramming. However, as we show, by
                  itself, guarded recursion is not suitable for coprogramming
                  due to the fact that there is no way to make finite
                  observations on pieces of infinite data. In this paper, we
                  introduce the concept of clock variables that index Nakano's
                  guarded recursion. Clock variables allow us to "close over"
                  the generation of infinite data, and to make finite
                  observations, something that is not possible with guarded
                  recursion alone.},
  booktitle       = {Proceedings of the 18th ACM SIGPLAN International
                  Conference on Functional Programming},
  pages           = {197–208},
  numpages        = 12,
  keywords        = {coalgebras, corecursion, guarded recursion, total
                  functional programming},
  location        = {Boston, Massachusetts, USA},
  series          = {ICFP '13}
}

@phdthesis{gundryThesis,
  title={Type Inference, Haskell and Dependent Types},
  author={Adam Gundry},
  note={hhttp://adam.gundry.co.uk/pub/thesis/thesis-2013-12-03.pdf},
  year={2013},
  school={University of Strathclyde}
}

@article{10.1145/2518190,
  author          = {Chen, Sheng and Erwig, Martin and Walkingshaw, Eric},
  title           = {Extending Type Inference to Variational Programs},
  year            = 2014,
  issue_date      = {March 2014},
  publisher       = {Association for Computing Machinery},
  address         = {New York, NY, USA},
  volume          = 36,
  number          = 1,
  issn            = {0164-0925},
  url             = {https://doi.org/10.1145/2518190},
  doi             = {10.1145/2518190},
  abstract        = {Through the use of conditional compilation and related
                  tools, many software projects can be used to generate a huge
                  number of related programs. The problem of typing such
                  variational software is difficult. The brute-force strategy of
                  generating all variants and typing each one individually is:
                  (1) usually infeasible for efficiency reasons and (2) produces
                  results that do not map well to the underlying variational
                  program. Recent research has focused mainly on efficiency and
                  addressed only the problem of type checking. In this work we
                  tackle the more general problem of variational type inference
                  and introduce variational types to represent the result of
                  typing a variational program. We introduce the variational
                  lambda calculus (VLC) as a formal foundation for research on
                  typing variational programs. We define a type system for VLC
                  in which VLC expressions are mapped to correspondingly
                  variational types. We show that the type system is correct by
                  proving that the typing of expressions is preserved over the
                  process of variation elimination, which eventually results in
                  a plain lambda calculus expression and its corresponding type.
                  We identify a set of equivalence rules for variational types
                  and prove that the type unification problem modulo these
                  equivalence rules is unitary and decidable; we also present a
                  sound and complete unification algorithm. Based on the
                  unification algorithm, the variational type inference
                  algorithm is an extension of algorithm W. We show that it is
                  sound and complete and computes principal types. We also
                  consider the extension of VLC with sum types, a necessary
                  feature for supporting variational data types, and demonstrate
                  that the previous theoretical results also hold under this
                  extension. Finally, we characterize the complexity of
                  variational type inference and demonstrate the efficiency
                  gains over the brute-force strategy.},
  journal         = {ACM Trans. Program. Lang. Syst.},
  month           = mar,
  articleno       = 1,
  numpages        = 54,
  keywords        = {variational type inference, variational types, Variational
                  lambda calculus}
}
@phdthesis{ulfThesis,
    author = {Ulf Norell},
    note={http://www.cse.chalmers.se/~ulfn/papers/thesis.pdf},
    title = {Towards a practical programming language based on dependent type theory},
    year = {2007},
    school = {Chalmers University of Technology}
}

@article{10.1145/2544174.2500597,
  author          = {Atkey, Robert and McBride, Conor},
  title           = {Productive Coprogramming with Guarded Recursion},
  year            = 2013,
  issue_date      = {September 2013},
  publisher       = {Association for Computing Machinery},
  address         = {New York, NY, USA},
  volume          = 48,
  number          = 9,
  issn            = {0362-1340},
  url             = {https://doi.org/10.1145/2544174.2500597},
  doi             = {10.1145/2544174.2500597},
  abstract        = {Total functional programming offers the beguiling vision
                  that, just by virtue of the compiler accepting a program, we
                  are guaranteed that it will always terminate. In the case of
                  programs that are not intended to terminate, e.g., servers, we
                  are guaranteed that programs will always be productive.
                  Productivity means that, even if a program generates an
                  infinite amount of data, each piece will be generated in
                  finite time. The theoretical underpinning for productive
                  programming with infinite output is provided by the category
                  theoretic notion of final coalgebras. Hence, we speak of
                  coprogramming with non-well-founded codata, as a dual to
                  programming with well-founded data like finite lists and
                  trees.Systems that offer facilities for productive
                  coprogramming, such as the proof assistants Coq and Agda,
                  currently do so through syntactic guardedness checkers.
                  Syntactic guardedness checkers ensure that all self-recursive
                  calls are guarded by a use of a constructor. Such a check
                  ensures productivity. Unfortunately, these syntactic checks
                  are not compositional, and severely complicate
                  coprogramming.Guarded recursion, originally due to Nakano, is
                  tantalising as a basis for a flexible and compositional
                  type-based approach to coprogramming. However, as we show, by
                  itself, guarded recursion is not suitable for coprogramming
                  due to the fact that there is no way to make finite
                  observations on pieces of infinite data. In this paper, we
                  introduce the concept of clock variables that index Nakano's
                  guarded recursion. Clock variables allow us to "close over"
                  the generation of infinite data, and to make finite
                  observations, something that is not possible with guarded
                  recursion alone.},
  journal         = {SIGPLAN Not.},
  month           = sep,
  pages           = {197–208},
  numpages        = 12,
  keywords        = {guarded recursion, coalgebras, total functional
                  programming, corecursion}
}

@inproceedings{10.1145/2976022.2976031,
  author          = {Diehl, Larry and Sheard, Tim},
  title           = {Generic Lookup and Update for Infinitary
                  Inductive-Recursive Types},
  year            = 2016,
  isbn            = 9781450344357,
  publisher       = {Association for Computing Machinery},
  address         = {New York, NY, USA},
  url             = {https://doi.org/10.1145/2976022.2976031},
  doi             = {10.1145/2976022.2976031},
  booktitle       = {Proceedings of the 1st International Workshop on
                  Type-Driven Development},
  pages           = {1–12},
  numpages        = 12,
  keywords        = {Dependent types, induction-recursion, generic programming},
  location        = {Nara, Japan},
  series          = {TyDe 2016}
}

@inproceedings{10.1145/3018610.3018620,
  author          = {Boulier, Simon and P\'{e}drot, Pierre-Marie and Tabareau,
                  Nicolas},
  title           = {The next 700 Syntactical Models of Type Theory},
  year            = 2017,
  isbn            = 9781450347051,
  publisher       = {Association for Computing Machinery},
  address         = {New York, NY, USA},
  url             = {https://doi.org/10.1145/3018610.3018620},
  doi             = {10.1145/3018610.3018620},
  abstract        = {A family of syntactic models for the calculus of
                  construction with universes (CCω) is described, all of them
                  preserving conversion of the calculus definitionally, and thus
                  giving rise directly to a program transformation of CCω into
                  itself. Those models are based on the remark that negative
                  type constructors (e.g. dependent product, coinductive types
                  or universes) are underspecified in type theory-which leaves
                  some freedom on extra intensional specifications. The model
                  construction can be seen as a compilation phase from a complex
                  type theory into a simpler type theory. Such models can be
                  used to derive (the negative part of) independence results
                  with respect to CCω, such as functional extensionality,
                  propositional extensionality, univalence or the fact that
                  bisimulation on a coinductive type may not coincide with
                  equality. They can also be used to add new principles to the
                  theory, which we illustrate by defining a version of CCω with
                  ad-hoc polymorphism that shows in particular that
                  parametricity is not an implicit requirement of type theory.
                  The correctness of some of the models/program transformations
                  have been checked in the Coq proof assistant and have been
                  instrumented as a Coq plugin.},
  booktitle       = {Proceedings of the 6th ACM SIGPLAN Conference on Certified
                  Programs and Proofs},
  pages           = {182–194},
  numpages        = 13,
  keywords        = {Program translation, Dependent type theory},
  location        = {Paris, France},
  series          = {CPP 2017}
}

@inproceedings{10.1145/3209108.3209153,
  author          = {Sterling, Jonathan and Harper, Robert},
  title           = {Guarded Computational Type Theory},
  year            = 2018,
  isbn            = 9781450355834,
  publisher       = {Association for Computing Machinery},
  address         = {New York, NY, USA},
  url             = {https://doi.org/10.1145/3209108.3209153},
  doi             = {10.1145/3209108.3209153},
  abstract        = {Nakano's later modality can be used to specify and define
                  recursive functions which are causal or synchronous; in
                  concert with a notion of clock variable, it is possible to
                  also capture the broader class of productive (co)programs.
                  Until now, it has been difficult to combine these constructs
                  with dependent types in a way that preserves the operational
                  meaning of type theory and admits a hierarchy of universes
                  Ui.We present an operational account of guarded dependent type
                  theory with clocks called CTT, featuring a novel clock
                  intersection connective {k undefined clk} → A that enjoys the
                  clock irrelevance principle, as well as a predicative
                  hierarchy of universes Ui which does not require any indexing
                  in clock contexts. CTT is simultaneously a programming
                  language with a rich specification logic, as well as a
                  computational metalanguage that can be used to develop
                  semantics of other languages and logics.},
  booktitle       = {Proceedings of the 33rd Annual ACM/IEEE Symposium on Logic
                  in Computer Science},
  pages           = {879–888},
  numpages        = 10,
  keywords        = {guarded recursion, type theory, dependent types,
                  operational semantics, clocks},
  location        = {Oxford, United Kingdom},
  series          = {LICS '18}
}

@article{ANDERSON200353,
title = {BabyJ: From Object Based to Class Based Programming via Types},
journal = {Electronic Notes in Theoretical Computer Science},
volume = {82},
number = {8},
pages = {53-81},
year = {2003},
note = {WOOD2003, Workshop on Object Oriented Developments (Satellite Event of ETAPS 2003)},
issn = {1571-0661},
doi = {https://doi.org/10.1016/S1571-0661(04)80802-8},
url = {https://www.sciencedirect.com/science/article/pii/S1571066104808028},
author = {Christopher Anderson and Sophia Drossopoulou},
keywords = {object based calculi, class based calculi, program transformation, types},
abstract = {Object oriented programming can be classified into the object based, and the class based paradigm. Object based languages typically are weakly typed and interpreted, allow member addition and removal, and thus they support flexibility and prototyping. Class based languages are usually strongly typed and compiled, require a rigid class structure and class membership, and thus they support more robust, type safe programs. The two paradigms therefore address the needs of different stages in the programming lifecycle: object based programming better fits the earlier, exploratory phases, whereas class based better fits the latter, consolidation and maintenance phases. Because the transition from one paradigm to the other is not straightforward, programs tend to be developed in one of the two paradigms, thus foregoing the advantages of the other. We suggest that this need not be so, and that the benefits of the two paradigms can be combined: The earlier, exploratory, programming phases should take place in an object based setting. Then, the program should be incrementally annotated with types. Once fully typed, the program can be mapped onto an equivalent class based program. We demonstrate these ideas through the introduction of BabyJ, a formalization of Javascript. We define BabyJT, a typed extension of BabyJ. A permissive type in BabyJ allows the typing process to be incremental. We then define a meaning preserving transformation of BabyJT programs to Java programs.}
}

@article{10.1145/3236768,
  author          = {New, Max S. and Ahmed, Amal},
  title           = {Graduality from Embedding-Projection Pairs},
  year            = 2018,
  issue_date      = {July 2018},
  publisher       = {Association for Computing Machinery},
  address         = {New York, NY, USA},
  volume          = 2,
  number          = {ICFP},
  url             = {https://doi.org/10.1145/3236768},
  doi             = {10.1145/3236768},
  journal         = {Proc. ACM Program. Lang.},
  month           = jul,
  articleno       = {Article 73},
  numpages        = 30,
  keywords        = {observational error approximation, dynamic gradual
                  guarantee, logical relations, gradual typing}
}

@article{10.1145/3371071,
  author          = {Chang, Stephen and Ballantyne, Michael and Turner, Milo and
                  Bowman, William J.},
  title           = {Dependent Type Systems as Macros},
  year            = 2019,
  issue_date      = {January 2020},
  publisher       = {Association for Computing Machinery},
  address         = {New York, NY, USA},
  volume          = 4,
  number          = {POPL},
  url             = {https://doi.org/10.1145/3371071},
  doi             = {10.1145/3371071},
  journal         = {Proc. ACM Program. Lang.},
  month           = dec,
  articleno       = {Article 3},
  numpages        = 29,
  keywords        = {proof assistants, dependent types, type systems, macros}
}

@article{10.1145/3371071,
  author          = {Chang, Stephen and Ballantyne, Michael and Turner, Milo and
                  Bowman, William J.},
  title           = {Dependent Type Systems as Macros},
  year            = 2019,
  issue_date      = {January 2020},
  publisher       = {Association for Computing Machinery},
  address         = {New York, NY, USA},
  volume          = 4,
  number          = {POPL},
  url             = {https://doi.org/10.1145/3371071},
  doi             = {10.1145/3371071},
  journal         = {Proc. ACM Program. Lang.},
  month           = dec,
  articleno       = 3,
  numpages        = 29,
  keywords        = {dependent types, macros, type systems, proof assistants}
}

@phdthesis{heerenThesis,
  title={Top quality type error messages},
  author={Heeren, Bastiaan J},
  note={{IPA} Dissertation Series, \url{https://dspace.library.uu.nl/handle/1874/7297}},
  year={2005},
  publisher={Utrecht University}
}

@article{10.1145/3371114,
  author          = {New, Max S. and Jamner, Dustin and Ahmed, Amal},
  title           = {Graduality and Parametricity: Together Again for the First
                  Time},
  year            = 2019,
  issue_date      = {January 2020},
  publisher       = {Association for Computing Machinery},
  address         = {New York, NY, USA},
  volume          = 4,
  number          = {POPL},
  url             = {https://doi.org/10.1145/3371114},
  doi             = {10.1145/3371114},
  journal         = {Proc. ACM Program. Lang.},
  month           = dec,
  articleno       = 46,
  numpages        = 32,
  keywords        = {logical relation, polymorphism, gradual typing,
                  parametricity, graduality}
}

@inproceedings{10.1145/3372885.3373814,
  author          = {Veltri, Niccol\`{o} and Vezzosi, Andrea},
  title           = {Formalizing $\pi$-Calculus in Guarded Cubical Agda},
  year            = 2020,
  isbn            = 9781450370974,
  publisher       = {Association for Computing Machinery},
  address         = {New York, NY, USA},
  url             = {https://doi.org/10.1145/3372885.3373814},
  doi             = {10.1145/3372885.3373814},
  booktitle       = {Proceedings of the 9th ACM SIGPLAN International Conference
                  on Certified Programs and Proofs},
  pages           = {270–283},
  numpages        = 14,
  keywords        = {ticked cubical type theory, pi-calculus, denotational
                  semantics, guarded recursion},
  location        = {New Orleans, LA, USA},
  series          = {CPP 2020}
}

@article{10.1145/360248.360252,
  author          = {King, James C.},
  title           = {Symbolic Execution and Program Testing},
  year            = 1976,
  issue_date      = {July 1976},
  publisher       = {Association for Computing Machinery},
  address         = {New York, NY, USA},
  volume          = 19,
  number          = 7,
  issn            = {0001-0782},
  url             = {https://doi.org/10.1145/360248.360252},
  doi             = {10.1145/360248.360252},
  abstract        = {This paper describes the symbolic execution of programs.
                  Instead of supplying the normal inputs to a program (e.g.
                  numbers) one supplies symbols representing arbitrary values.
                  The execution proceeds as in a normal execution except that
                  values may be symbolic formulas over the input symbols. The
                  difficult, yet interesting issues arise during the symbolic
                  execution of conditional branch type statements. A particular
                  system called EFFIGY which provides symbolic execution for
                  program testing and debugging is also described. It
                  interpretively executes programs written in a simple PL/I
                  style programming language. It includes many standard
                  debugging features, the ability to manage and to prove things
                  about symbolic expressions, a simple program testing manager,
                  and a program verifier. A brief discussion of the relationship
                  between symbolic execution and program proving is also
                  included.},
  journal         = {Commun. ACM},
  month           = jul,
  pages           = {385–394},
  numpages        = 10,
  keywords        = {program verification, program testing, symbolic execution,
                  program debugging, symbolic interpretation, program proving}
}

@inproceedings{10.1145/75277.75283,
  author          = {Wadler, P. and Blott, S.},
  title           = {How to Make Ad-Hoc Polymorphism Less Ad Hoc},
  year            = 1989,
  isbn            = 0897912942,
  publisher       = {Association for Computing Machinery},
  address         = {New York, NY, USA},
  url             = {https://doi.org/10.1145/75277.75283},
  doi             = {10.1145/75277.75283},
  booktitle       = {Proceedings of the 16th ACM SIGPLAN-SIGACT Symposium on
                  Principles of Programming Languages},
  pages           = {60–76},
  numpages        = 17,
  location        = {Austin, Texas, USA},
  series          = {POPL ’89}
}

@INPROCEEDINGS{113732,
  author          = {N. {Heintze} and J. {Jaffar}},
  booktitle       = {[1990] Proceedings. Fifth Annual IEEE Symposium on Logic in
                  Computer Science},
  title           = {A decision procedure for a class of set constraints},
  year            = 1990,
  pages           = {42-51},
  keywords        = {decidability;formal logic;decision procedure;class of set
                  constraints;set expressions;variables;function
                  symbols;projection symbols;set union;intersection;complement
                  symbols;satisfiability problem;program analysis;least
                  model;solved form constraint;Calculus;Binary search
                  trees;Reasoning about programs;Cost function;Runtime;Logic},
  doi             = {10.1109/LICS.1990.113732},
  month           = {June},
}

@INPROCEEDINGS{185545,
  author          = {A. {Aiken} and E. L. {Wimmers}},
  booktitle       = {[1992] Proceedings of the Seventh Annual IEEE Symposium on
                  Logic in Computer Science},
  title           = {Solving systems of set constraints},
  year            = 1992,
  pages           = {329-340},
  keywords        = {algorithm theory;automata theory;constraint theory;set
                  theory;set constraints;set operations;unrestricted
                  union;complement;tree automata;Automata;Algorithm design and
                  analysis;Inference algorithms;Logic programming;Upper bound},
  doi             = {10.1109/LICS.1992.185545},
  month           = {June},
}

@INPROCEEDINGS{287598,
  author          = {L. {Bachmair} and H. {Ganzinger} and U. {Waldmann}},
  booktitle       = {[1993] Proceedings Eighth Annual IEEE Symposium on Logic in
                  Computer Science},
  title           = {Set constraints are the monadic class},
  year            = 1993,
  pages           = {75-83},
  keywords        = {computational complexity;constraint theory;decidability;set
                  theory;set constraints;monadic class;first-order
                  formulas;equivalence;satisfiability
                  problem;completeness;NEXPTIME;NTIME;lower
                  bound;decidability;complexity;negative projections;subterm
                  equality tests;Testing;Constraint
                  theory;Vocabulary;Abstracts;Concrete;Algorithm design and
                  analysis;Inference algorithms;Computer science;Logic
                  programming;Computer languages},
  doi             = {10.1109/LICS.1993.287598},
  month           = {June},
}

@INPROCEEDINGS{316078,
  author          = {W. {Charatonik} and L. {Pacholski}},
  booktitle       = {Proceedings Ninth Annual IEEE Symposium on Logic in
                  Computer Science},
  title           = {Negative set constraints with equality},
  year            = 1994,
  pages           = {128-136},
  keywords        = {type theory;decidability;formal logic;set theory;program
                  verification;negative set constraints;equality;ground
                  terms;program analysis;type inference;decidability;mixed set
                  constraints;monadic class;simple algorithm;NEXPTIME;proof of
                  correctness;consistency;restricted projections;unrestricted
                  diagonalization;Automata;Constraint theory;Computer
                  science;Mathematics;Algorithm design and analysis},
  doi             = {10.1109/LICS.1994.316078},
  month           = {July},
}

@INPROCEEDINGS{5970227,
  author          = {L. {Birkedal} and R. E. {Mogelberg} and J. {Schwinghammer}
                  and K. {Stovring}},
  booktitle       = {2011 IEEE 26th Annual Symposium on Logic in Computer
                  Science},
  title           = {First Steps in Synthetic Guarded Domain Theory:
                  Step-Indexing in the Topos of Trees},
  year            = 2011,
  pages           = {55-64},
  doi             = {10.1109/LICS.2011.16}
}

@INPROCEEDINGS{6571553,
  author          = {L. {Birkedal} and R. E. {Møgelberg}},
  booktitle       = {2013 28th Annual ACM/IEEE Symposium on Logic in Computer
                  Science},
  title           = {Intensional Type Theory with Guarded Recursive Types qua
                  Fixed Points on Universes},
  year            = 2013,
  pages           = {213-222},
  doi             = {10.1109/LICS.2013.27}
}

@INPROCEEDINGS{6595831,
  author          = {L. Fennell and P. Thiemann},
  booktitle       = {2013 IEEE 26th Computer Security Foundations Symposium},
  title           = {Gradual Security Typing with References},
  year            = 2013,
  pages           = {224-239},
  keywords        = {ML language;program diagnostics;security of data;gradual
                  security typing;information-flow control;IFC;dynamic run-time
                  monitoring;permissive dynamic checking;conservative static
                  type system;ML-GS;reference type;static checking;security
                  cast;higher-order function;monomorphic ML core
                  language;Security;Context;Standards;Syntactics;Monitoring;Radiation
                  detectors;Semantics;gradual typing;security
                  typing;ML;references},
  doi             = {10.1109/CSF.2013.22},
  ISSN            = {2377-5459},
  month           = {June},
}

@INPROCEEDINGS{8005113,
  author          = {P. {P{\'e}drot} and N. {Tabareau}},
  booktitle       = {2017 32nd Annual ACM/IEEE Symposium on Logic in Computer
                  Science (LICS)},
  title           = {An effectful way to eliminate addiction to dependence},
  year            = 2017,
  pages           = {1-12},
  keywords        = {program interpreters;monadic translation;dependent type
                  theory;weaning translation;exception operation;nontermination
                  operation;nondeterminism operation;writing
                  operation;call-by-push-value decomposition;calculus of
                  inductive constructions;CIC;parametricity
                  techniques;Algebra;Syntactics;Mathematical
                  model;Writing;Functional programming;Coherence;Calculus},
  doi             = {10.1109/LICS.2017.8005113},
  month           = {June},
}

[download]

@INPROCEEDINGS{855774,
  author          = {H. {Nakano}},
  booktitle       = {Proceedings Fifteenth Annual IEEE Symposium on Logic in
                  Computer Science (Cat. No.99CB36332)},
  title           = {A modality for recursion},
  year            = 2000,
  pages           = {255-266},
}

@INPROCEEDINGS{855774,
  author          = {H. {Nakano}},
  booktitle       = {Proceedings Fifteenth Annual IEEE Symposium on Logic in
                  Computer Science (Cat. No.99CB36332)},
  title           = {A modality for recursion},
  year            = 2000,
  pages           = {255-266},
  doi             = {10.1109/LICS.2000.855774}
}

@TECHREPORT{Heeren01improvingtype-error,
    author = {Bastiaan Heeren and Johan Jeuring and Doaitse Swierstra and Pablo Azero Alcocer},
    title = {Improving Type-Error Messages in Functional Languages},
    institution = {},
    year = {2001}
}

@BOOK{qedAtLarge,
  author          = {T. {Ringer} and K. {Palmskog} and I. {Sergey} and M.
                  {Gligoric} and Z. {Tatlock}},
  booktitle       = {QED at Large: A Survey of Engineering of Formally Verified
                  Software},
  title           = {QED at Large: A Survey of Engineering of Formally Verified
                  Software},
  year            = 2019,
  ISSN            = {null},
  publisher       = {now},
  isbn            = {null},
  url             = {https://ieeexplore.ieee.org/document/8824174},
}

@article{AIKEN199530,
  title           = "Decidability of Systems of Set Constraints with Negative
                  Constraints",
  journal         = "Information and Computation",
  volume          = 122,
  number          = 1,
  pages           = "30 - 44",
  year            = 1995,
  issn            = "0890-5401",
  doi             = "https://doi.org/10.1006/inco.1995.1139",
  url             = "http://www.sciencedirect.com/science/article/pii/S089054018571139X",
  author          = "A. Aiken and D. Kozen and E. Wimmers"
}

@article{AIKEN199530,
  title           = "Decidability of Systems of Set Constraints with Negative
                  Constraints",
  journal         = "Information and Computation",
  volume          = 122,
  number          = 1,
  pages           = "30 - 44",
  year            = 1995,
  issn            = "0890-5401",
  doi             = "https://doi.org/10.1006/inco.1995.1139",
  url             = "http://www.sciencedirect.com/science/article/pii/S089054018571139X",
  author          = "A. Aiken and D. Kozen and E. Wimmers"
}

@article{AIKEN199979,
  title           = "Introduction to set constraint-based program analysis",
  journal         = "Science of Computer Programming",
  volume          = 35,
  number          = 2,
  pages           = "79 - 111",
  year            = 1999,
  issn            = "0167-6423",
  doi             = "https://doi.org/10.1016/S0167-6423(99)00007-6",
  url             = "http://www.sciencedirect.com/science/article/pii/S0167642399000076",
  author          = "Alexander Aiken",
  keywords        = "Constraints, Set constraints, Program analysis",
  abstract        = "This paper given an introduction to using set constraints
                  to specify program analyses. Several standard analysis
                  problems are formulated using set constraints, which serves
                  both to illustrate the style of using constraints to specify
                  program analysis problems and the range of application of set
                  constraints."
}

@book{Ackermann,
  title           = {Solvable cases of the decision problem},
  author          = {Ackermann, W.},
  lccn            = {lc55001655},
  series          = {Studies in logic and the foundations of mathematics},
  year            = 1954,
  publisher       = {North-Holland Pub. Co.}
}

@article{Ahmed:2011:BLA:1925844.1926409,
  author          = {Ahmed, Amal and Findler, Robert Bruce and Siek, Jeremy G.
                  and Wadler, Philip},
  title           = {Blame for All},
  journal         = {SIGPLAN Not.},
  issue_date      = {January 2011},
  volume          = 46,
  number          = 1,
  month           = jan,
  year            = 2011,
  issn            = {0362-1340},
  pages           = {201--214},
  numpages        = 14,
  url             = {http://doi.acm.org/10.1145/1925844.1926409},
  doi             = {10.1145/1925844.1926409},
  acmid           = 1926409,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {blame tracking, casts, coercions, lambda-calculus},
}

@inproceedings{Aiken:1993:TIC:165180.165188,
  author          = {Aiken, Alexander and Wimmers, Edward L.},
  title           = {Type Inclusion Constraints and Type Inference},
  booktitle       = {Proceedings of the Conference on Functional Programming
                  Languages and Computer Architecture},
  series          = {FPCA '93},
  year            = 1993,
  isbn            = {0-89791-595-X},
  location        = {Copenhagen, Denmark},
  pages           = {31--41},
  numpages        = 11,
  url             = {http://doi.acm.org/10.1145/165180.165188},
  doi             = {10.1145/165180.165188},
  acmid           = 165188,
  publisher       = {ACM},
  address         = {New York, NY, USA},
}

@inproceedings{Aiken:1994:STC:174675.177847,
  author          = {Aiken, Alexander and Wimmers, Edward L. and Lakshman, T.
                  K.},
  title           = {Soft Typing with Conditional Types},
  booktitle       = {Proceedings of the 21st ACM SIGPLAN-SIGACT Symposium on
                  Principles of Programming Languages},
  series          = {POPL '94},
  year            = 1994,
  isbn            = {0-89791-636-0},
  location        = {Portland, Oregon, USA},
  pages           = {163--173},
  numpages        = 11,
  url             = {http://doi.acm.org/10.1145/174675.177847},
  doi             = {10.1145/174675.177847},
  acmid           = 177847,
  publisher       = {ACM},
  address         = {New York, NY, USA},
}

@Inbook{Altenkirch2003,
  author          = "Altenkirch, Thorsten and Mcbride, Conor",
  editor          = "Gibbons, Jeremy and Jeuring, Johan",
  title           = "Generic Programming within Dependently Typed Programming",
  bookTitle       = "Generic Programming: IFIP TC2 / WG2.1 Working Conference
                  Programming July 11--12, 2002, Dagstuhl, Germany",
  year            = 2003,
  publisher       = "Springer US",
  address         = "Boston, MA",
  pages           = "1--20",
  abstract        = "We show how higher kinded generic programming can be
                  represented faithfully within a dependently typed programming
                  system. This development has been implemented using the Oleg
                  system.",
  isbn            = "978-0-387-35672-3",
  doi             = "10.1007/978-0-387-35672-3_1",
  url             = "https://doi.org/10.1007/978-0-387-35672-3_1"
}

@inproceedings{Altenkirch:2007:OE:1292597.1292608,
  author          = {Altenkirch, Thorsten and McBride, Conor and Swierstra,
                  Wouter},
  title           = {Observational Equality, Now!},
  booktitle       = {Proceedings of the 2007 Workshop on Programming Languages
                  Meets Program Verification},
  series          = {PLPV '07},
  year            = 2007,
  isbn            = {978-1-59593-677-6},
  location        = {Freiburg, Germany},
  pages           = {57--68},
  numpages        = 12,
  url             = {http://doi.acm.org/10.1145/1292597.1292608},
  doi             = {10.1145/1292597.1292608},
  acmid           = 1292608,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {equality, type theory},
}

@incollection{Barendregt:1993:LCT:162552.162561,
  author          = {Barendregt, H. P.},
  chapter         = {Lambda Calculi with Types},
  title           = {Handbook of Logic in Computer Science (Vol. 2)},
  editor          = {Abramsky, S. and Gabbay, Dov M. and Maibaum, S. E.},
  year            = 1992,
  isbn            = {0-19-853761-1},
  pages           = {117--309},
  numpages        = 193,
  url             = {http://dl.acm.org/citation.cfm?id=162552.162561},
  acmid           = 162561,
  publisher       = {Oxford University Press, Inc.},
  address         = {New York, NY, USA},
}

@inproceedings{Brady:2010:SYI:1863543.1863587,
  author          = {Brady, Edwin C. and Hammond, Kevin},
  title           = {Scrapping Your Inefficient Engine: Using Partial Evaluation
                  to Improve Domain-specific Language Implementation},
  booktitle       = {Proceedings of the 15th ACM SIGPLAN International
                  Conference on Functional Programming},
  series          = {ICFP '10},
  year            = 2010,
  isbn            = {978-1-60558-794-3},
  location        = {Baltimore, Maryland, USA},
  pages           = {297--308},
  numpages        = 12,
  url             = {http://doi.acm.org/10.1145/1863543.1863587},
  doi             = {10.1145/1863543.1863587},
  acmid           = 1863587,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {dependent types, partial evaluation},
}

@article{COQUAND198895,
  title           = "The calculus of constructions",
  journal         = "Information and Computation",
  volume          = 76,
  number          = 2,
  pages           = "95 - 120",
  year            = 1988,
  issn            = "0890-5401",
  doi             = "https://doi.org/10.1016/0890-5401(88)90005-3",
  url             = "http://www.sciencedirect.com/science/article/pii/0890540188900053",
  author          = "Thierry Coquand and G{\'e}rard Huet"
}

@inproceedings{Casinghino:2014:CPP:2535838.2535883,
  author          = {Casinghino, Chris and Sj\"{o}berg, Vilhelm and Weirich,
                  Stephanie},
  title           = {Combining Proofs and Programs in a Dependently Typed
                  Language},
  booktitle       = {Proceedings of the 41st ACM SIGPLAN-SIGACT Symposium on
                  Principles of Programming Languages},
  series          = {POPL '14},
  year            = 2014,
  isbn            = {978-1-4503-2544-8},
  location        = {San Diego, California, USA},
  pages           = {33--45},
  numpages        = 13,
  url             = {http://doi.acm.org/10.1145/2535838.2535883},
  doi             = {10.1145/2535838.2535883},
  acmid           = 2535883,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {dependent types, general recursion, termination},
}
@TECHREPORT{hereditary,
author="Watkins, Kevin
and Cervesato, Iliano
and Pfenning, Frank
and Walker, David",
title="A Concurrent Logical Framework {I}: Judgments and Properties",
year="2003",
note={\url{https://www.cs.cmu.edu/~fp/papers/CMU-CS-02-101.pdf}},
publisher="School of Computer Science, Carnegie Mellon University",
number =        {CMU-CS-02-101},
howpublished = {Technical Report. \url{https://www.cs.cmu.edu/~fp/papers/CMU-CS-02-101.pdf} },
   publisher = {Technical Report, \url{https://www.cs.cmu.edu/~fp/papers/CMU-CS-02-101.pdf} },
}

@inproceedings{Castagna:2015:PFS:2676726.2676991,
  author          = {Castagna, Giuseppe and Nguyen, Kim and Xu, Zhiwu and Abate,
                  Pietro},
  title           = {Polymorphic Functions with Set-Theoretic Types: Part 2:
                  Local Type Inference and Type Reconstruction},
  booktitle       = {Proceedings of the 42Nd Annual ACM SIGPLAN-SIGACT Symposium
                  on Principles of Programming Languages},
  series          = {POPL '15},
  year            = 2015,
  isbn            = {978-1-4503-3300-9},
  location        = {Mumbai, India},
  pages           = {289--302},
  numpages        = 14,
  url             = {http://doi.acm.org/10.1145/2676726.2676991},
  doi             = {10.1145/2676726.2676991},
  acmid           = 2676991,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {intersection types, polymorphism, semantic subtyping, type
                  constraints, types, xml},
}

@article{Castagna:2017:GTU:3136534.3110285,
  author          = {Castagna, Giuseppe and Lanvin, Victor},
  title           = {Gradual Typing with Union and Intersection Types},
  journal         = {Proc. ACM Program. Lang.},
  issue_date      = {September 2017},
  volume          = 1,
  number          = {ICFP},
  month           = aug,
  year            = 2017,
  issn            = {2475-1421},
  pages           = {41:1--41:28},
  articleno       = 41,
  numpages        = 28,
  url             = {http://doi.acm.org/10.1145/3110285},
  doi             = {10.1145/3110285},
  acmid           = 3110285,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {Gradual typing, intersection types, negation types,
                  set-theoretic types, union types},
}

@inproceedings{Chapman:2010:GAL:1863543.1863547,
  author          = {Chapman, James and Dagand, Pierre-\'{E}variste and McBride,
                  Conor and Morris, Peter},
  title           = {The Gentle Art of Levitation},
  booktitle       = {Proceedings of the 15th ACM SIGPLAN International
                  Conference on Functional Programming},
  series          = {ICFP '10},
  year            = 2010,
  isbn            = {978-1-60558-794-3},
  location        = {Baltimore, Maryland, USA},
  pages           = {3--14},
  numpages        = 12,
  url             = {http://doi.acm.org/10.1145/1863543.1863547},
  doi             = {10.1145/1863543.1863547},
  acmid           = 1863547,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {data structure, metaprogramming, monads, proof assistants,
                  type systems},
},

@inproceedings{Chen:2005:CPT:1086365.1086375,
  author          = {Chen, Chiyan and Xi, Hongwei},
  title           = {Combining Programming with Theorem Proving},
  booktitle       = {Proceedings of the Tenth ACM SIGPLAN International
                  Conference on Functional Programming},
  series          = {ICFP '05},
  year            = 2005,
  isbn            = {1-59593-064-7},
  location        = {Tallinn, Estonia},
  pages           = {66--77},
  numpages        = 12,
  url             = {http://doi.acm.org/10.1145/1086365.1086375},
  doi             = {10.1145/1086365.1086375},
  acmid           = 1086375,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {ATS, applied type system, dependent types, proof erasure,
                  theorem proving},
}

@article{ChoiceCalc,
  author          = {Erwig, Martin and Walkingshaw, Eric},
  title           = {The Choice Calculus: A Representation for Software
                  Variation},
  journal         = {ACM Trans. Softw. Eng. Methodol.},
  issue_date      = {December 2011},
  volume          = 21,
  number          = 1,
  month           = dec,
  year            = 2011,
  issn            = {1049-331X},
  pages           = {6:1--6:27},
  articleno       = 6,
  numpages        = 27,
  url             = {http://doi.acm.org/10.1145/2063239.2063245},
  doi             = {10.1145/2063239.2063245},
  acmid           = 2063245,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {Variation, representation},
}

@inproceedings{Christiansen:2016:ERE:2951913.2951932,
  author          = {Christiansen, David and Brady, Edwin},
  title           = {Elaborator Reflection: Extending Idris in Idris},
  booktitle       = {Proceedings of the 21st ACM SIGPLAN International
                  Conference on Functional Programming},
  series          = {ICFP 2016},
  year            = 2016,
  isbn            = {978-1-4503-4219-3},
  location        = {Nara, Japan},
  pages           = {284--297},
  numpages        = 14,
  url             = {http://doi.acm.org/10.1145/2951913.2951932},
  doi             = {10.1145/2951913.2951932},
  acmid           = 2951932,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {Metaprogramming, dependent types, elaboration},
}

@inproceedings{Cimini:2016:GMA:2837614.2837632,
  author          = {Cimini, Matteo and Siek, Jeremy G.},
  title           = {The Gradualizer: A Methodology and Algorithm for Generating
                  Gradual Type Systems},
  booktitle       = {Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium
                  on Principles of Programming Languages},
  series          = {POPL '16},
  year            = 2016,
  isbn            = {978-1-4503-3549-2},
  location        = {St. Petersburg, FL, USA},
  pages           = {443--455},
  numpages        = 13,
  url             = {http://doi.acm.org/10.1145/2837614.2837632},
  doi             = {10.1145/2837614.2837632},
  acmid           = 2837632,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {gradual typing, methodology, semantics, type systems},
}

@article{Cockx:2018:EDP:3243631.3236770,
  author          = {Cockx, Jesper and Abel, Andreas},
  title           = {Elaborating Dependent (Co)Pattern Matching},
  journal         = {Proc. ACM Program. Lang.},
  issue_date      = {September 2018},
  volume          = 2,
  number          = {ICFP},
  month           = jul,
  year            = 2018,
  issn            = {2475-1421},
  pages           = {75:1--75:30},
  articleno       = 75,
  numpages        = 30,
  url             = {http://doi.acm.org/10.1145/3236770},
  doi             = {10.1145/3236770},
  acmid           = 3236770,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {Agda, Copatterns, Dependent pattern matching, Dependent
                  types},
}

@inproceedings{Coquand86,
  added-at        = {2015-01-22T00:00:00.000+0100},
  author          = {Coquand, Thierry},
  biburl          = {https://www.bibsonomy.org/bibtex/2ebbf0a12a09a966cc9188dab06c6c9e3/dblp},
  booktitle       = {LICS},
  crossref        = {conf/lics/1986},
  interhash       = {f2d80f4842fd7e0acced335429343746},
  intrahash       = {ebbf0a12a09a966cc9188dab06c6c9e3},
  isbn            = {0-8186-0720-3},
  keywords        = {dblp},
  pages           = {227-236},
  publisher       = {IEEE Computer Society},
  timestamp       = {2015-06-20T03:11:52.000+0200},
  title           = {An Analysis of Girard's Paradox},
  url             = {http://dblp.uni-trier.de/db/conf/lics/lics86.html\#Coquand86},
  year            = 1986
}

@inproceedings{Cousot:1977:AIU:512950.512973,
  author          = {Cousot, Patrick and Cousot, Radhia},
  title           = {Abstract Interpretation: A Unified Lattice Model for Static
                  Analysis of Programs by Construction or Approximation of
                  Fixpoints},
  booktitle       = {Proceedings of the 4th ACM SIGACT-SIGPLAN Symposium on
                  Principles of Programming Languages},
  series          = {POPL '77},
  year            = 1977,
  location        = {Los Angeles, California},
  pages           = {238--252},
  numpages        = 15,
  url             = {http://doi.acm.org.ezproxy.library.ubc.ca/10.1145/512950.512973},
  doi             = {10.1145/512950.512973},
  acmid           = 512973,
  publisher       = {ACM},
  address         = {New York, NY, USA},
}

@proceedings{DBLP:conf/cefp/2007,
  editor          = {Zolt{\'{a}}n Horv{\'{a}}th and Rinus Plasmeijer and Anna
                  So{\'{o}}s and Vikt{\'{o}}ria Zs{\'{o}}k},
  title           = {Central European Functional Programming School, Second
                  Summer School, {CEFP} 2007, Cluj-Napoca, Romania, June 23-30,
                  2007, Revised Selected Lectures},
  series          = {Lecture Notes in Computer Science},
  volume          = 5161,
  publisher       = {Springer},
  year            = 2008,
  url             = {https://doi.org/10.1007/978-3-540-88059-2},
  doi             = {10.1007/978-3-540-88059-2},
  isbn            = {978-3-540-88058-5},
  timestamp       = {Tue, 13 Jun 2017 10:37:56 +0200},
  biburl          = {https://dblp.org/rec/bib/conf/cefp/2007},
  bibsource       = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/cefp/SheardL07,
  author          = {Tim Sheard and Nathan Linger},
  title           = {Programming in Omega},
  booktitle       = {Central European Functional Programming School, Second
                  Summer School, {CEFP} 2007, Cluj-Napoca, Romania, June 23-30,
                  2007, Revised Selected Lectures},
  pages           = {158--227},
  year            = 2007,
  crossref        = {DBLP:conf/cefp/2007},
  url             = {https://doi.org/10.1007/978-3-540-88059-2\_5},
  doi             = {10.1007/978-3-540-88059-2\_5},
  timestamp       = {Tue, 13 Jun 2017 10:37:56 +0200},
  biburl          = {https://dblp.org/rec/bib/conf/cefp/SheardL07},
  bibsource       = {dblp computer science bibliography, https://dblp.org}
}

@proceedings{DBLP:conf/icfp/2008,
  editor          = {James Hook and Peter Thiemann},
  title           = {Proceeding of the 13th {ACM} {SIGPLAN} international
                  conference on Functional programming, {ICFP} 2008, Victoria,
                  BC, Canada, September 20-28, 2008},
  publisher       = {{ACM}},
  year            = 2008,
  isbn            = {978-1-59593-919-7},
  timestamp       = {Fri, 23 Jan 2009 12:52:56 +0100},
  biburl          = {https://dblp.org/rec/bib/conf/icfp/2008},
  bibsource       = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/icfp/JiaVMZZSZ08,
  author          = {Limin Jia and Jeffrey A. Vaughan and Karl Mazurak and
                  Jianzhou Zhao and Luke Zarko and Joseph Schorr and Steve
                  Zdancewic},
  title           = {{AURA:} a programming language for authorization and audit},
  booktitle       = {Proceeding of the 13th {ACM} {SIGPLAN} international
                  conference on Functional programming, {ICFP} 2008, Victoria,
                  BC, Canada, September 20-28, 2008},
  pages           = {27--38},
  year            = 2008,
  crossref        = {DBLP:conf/icfp/2008},
  url             = {https://doi.org/10.1145/1411204.1411212},
  doi             = {10.1145/1411204.1411212},
  timestamp       = {Tue, 06 Nov 2018 16:59:24 +0100},
  biburl          = {https://dblp.org/rec/bib/conf/icfp/JiaVMZZSZ08},
  bibsource       = {dblp computer science bibliography, https://dblp.org}
}

@proceedings{DBLP:conf/types/2003,
  editor          = {Stefano Berardi and Mario Coppo and Ferruccio Damiani},
  title           = {Types for Proofs and Programs, International Workshop,
                  {TYPES} 2003, Torino, Italy, April 30 - May 4, 2003, Revised
                  Selected Papers},
  series          = {Lecture Notes in Computer Science},
  volume          = 3085,
  publisher       = {Springer},
  year            = 2004,
  url             = {https://doi.org/10.1007/b98246},
  doi             = {10.1007/b98246},
  isbn            = {3-540-22164-6},
  timestamp       = {Thu, 15 Jun 2017 21:39:32 +0200},
  biburl          = {https://dblp.org/rec/bib/conf/types/2003},
  bibsource       = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/types/BradyMM03,
  author          = {Edwin Brady and Conor McBride and James McKinna},
  title           = {Inductive Families Need Not Store Their Indices},
  booktitle       = {Types for Proofs and Programs, International Workshop,
                  {TYPES} 2003, Torino, Italy, April 30 - May 4, 2003, Revised
                  Selected Papers},
  pages           = {115--129},
  year            = 2003,
  crossref        = {DBLP:conf/types/2003},
  url             = {https://doi.org/10.1007/978-3-540-24849-1\_8},
  doi             = {10.1007/978-3-540-24849-1\_8},
  timestamp       = {Thu, 15 Jun 2017 21:39:32 +0200},
  biburl          = {https://dblp.org/rec/bib/conf/types/BradyMM03},
  bibsource       = {dblp computer science bibliography, https://dblp.org}
}

@techreport{coquand:inria-00076023,
  TITLE = {{An analysis of Girard's paradox}},
  AUTHOR = {Coquand, T.},
  URL = {https://hal.inria.fr/inria-00076023},
  NUMBER = {RR-0531},
  INSTITUTION = {{INRIA}},
  YEAR = {1986},
  MONTH = May,
  PDF = {https://hal.inria.fr/inria-00076023/file/RR-0531.pdf},
  HAL_ID = {inria-00076023},
  HAL_VERSION = {v1},
}

@article{DBLP:journals/corr/abs-1805-00155,
  author          = {Omar, Cyrus and Voysey, Ian and Chugh, Ravi and Hammer,
                  Matthew A.},
  title           = {Live Functional Programming with Typed Holes},
  journal         = {Proc. ACM Program. Lang.},
  issue_date      = {January 2019},
  volume          = 3,
  number          = {POPL},
  month           = jan,
  year            = 2019,
  issn            = {2475-1421},
  pages           = {14:1--14:32},
  articleno       = 14,
  numpages        = 32,
  url             = {http://doi.acm.org/10.1145/3290327},
  doi             = {10.1145/3290327},
  acmid           = 3290327,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {contextual modal type theory, gradual typing, live
                  programming, structured editing, typed holes},
}

@article{DBLP:journals/corr/abs-1905-09423,
  author          = {Joseph Eremondi},
  title           = {Set Constraints, Pattern Match Analysis, and {SMT}},
  journal         = {CoRR},
  volume          = {abs/1905.09423},
  year            = 2019,
  url             = {http://arxiv.org/abs/1905.09423},
  archivePrefix   = {arXiv},
  eprint          = {1905.09423},
  timestamp       = {Wed, 29 May 2019 11:27:50 +0200},
  biburl          = {https://dblp.org/rec/journals/corr/abs-1905-09423.bib},
  bibsource       = {dblp computer science bibliography, https://dblp.org}
}

@article{DBLP:journals/pacmpl/OmarVCH19,
  author          = {Cyrus Omar and Ian Voysey and Ravi Chugh and Matthew A.
                  Hammer},
  title           = {Live functional programming with typed holes},
  journal         = {{PACMPL}},
  volume          = 3,
  number          = {{POPL}},
  pages           = {14:1--14:32},
  year            = 2019,
  url             = {https://dl.acm.org/citation.cfm?id=3290327},
  timestamp       = {Tue, 22 Jan 2019 15:27:56 +0100},
  biburl          = {https://dblp.org/rec/bib/journals/pacmpl/OmarVCH19},
  bibsource       = {dblp computer science bibliography, https://dblp.org}
}

@article{DBLP:journals/toplas/ZhangMVJ17,
  author          = {Danfeng Zhang and Andrew C. Myers and Dimitrios Vytiniotis
                  and Simon L. {Peyton Jones}},
  title           = {SHErrLoc: {A} Static Holistic Error Locator},
  journal         = {{ACM} Trans. Program. Lang. Syst.},
  volume          = 39,
  number          = 4,
  pages           = {18:1--18:47},
  year            = 2017
}

@article{DYBJER20031,
  title           = "Induction–recursion and initial algebras",
  journal         = "Annals of Pure and Applied Logic",
  volume          = 124,
  number          = 1,
  pages           = "1 - 47",
  year            = 2003,
  issn            = "0168-0072",
  doi             = "https://doi.org/10.1016/S0168-0072(02)00096-9",
  url             = "http://www.sciencedirect.com/science/article/pii/S0168007202000969",
  author          = "Peter Dybjer and Anton Setzer",
  keywords        = "Dependent type theory, Martin-Löf type theory, Inductive
                  definitions, Inductive-recursive definitions, Initial
                  algebras, Large cardinals, Mahlo cardinals, Mahlo universes",
  abstract        = "Induction–recursion is a powerful definition method in
                  intuitionistic type theory. It extends (generalized) inductive
                  definitions and allows us to define all standard sets of
                  Martin-Löf type theory as well as a large collection of
                  commonly occurring inductive data structures. It also includes
                  a variety of universes which are constructive analogues of
                  inaccessibles and other large cardinals below the first Mahlo
                  cardinal. In this article we give a new compact formalization
                  of inductive–recursive definitions by modeling them as initial
                  algebras in slice categories. We give generic formation,
                  introduction, elimination, and equality rules generalizing the
                  usual rules of type theory. Moreover, we prove that the
                  elimination and equality rules are equivalent to the principle
                  of the existence of initial algebras for certain endofunctors.
                  We also show the equivalence of the current formulation with
                  the formulation of induction–recursion as a reflection
                  principle given in Dybjer and Setzer (Lecture Notes in Comput.
                  Sci. 2183 (2001) 93). Finally, we discuss two type-theoretic
                  analogues of Mahlo cardinals in set theory: an external Mahlo
                  universe which is defined by induction–recursion and captured
                  by our formalization, and an internal Mahlo universe, which
                  goes beyond induction–recursion. We show that the external
                  Mahlo universe, and therefore also the theory of
                  inductive–recursive definitions, have proof-theoretical
                  strength of at least Rathjen's theory KPM."
}

@misc{mcbrideOrnamental,
  title={Ornamental algebras, algebraic ornaments},
  author={McBride, Conor},
  url={http://plv.mpi-sws.org/plerg/papers/mcbride-ornaments-2up.pdf},
  year={2011}
}

@inproceedings{Dagand:2012:TFA:2364527.2364544,
  author          = {Dagand, Pierre-Evariste and McBride, Conor},
  title           = {Transporting Functions Across Ornaments},
  booktitle       = {Proceedings of the 17th ACM SIGPLAN International
                  Conference on Functional Programming},
  series          = {ICFP '12},
  year            = 2012,
  isbn            = {978-1-4503-1054-3},
  location        = {Copenhagen, Denmark},
  pages           = {103--114},
  numpages        = 12,
  url             = {http://doi.acm.org/10.1145/2364527.2364544},
  doi             = {10.1145/2364527.2364544},
  acmid           = 2364544,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {datatype, dependent types, ornament},
}

@inproceedings{Damas:1982:PTF:582153.582176,
  author          = {Damas, Luis and Milner, Robin},
  title           = {Principal Type-schemes for Functional Programs},
  booktitle       = {Proceedings of the 9th ACM SIGPLAN-SIGACT Symposium on
                  Principles of Programming Languages},
  series          = {POPL '82},
  year            = 1982,
  isbn            = {0-89791-065-6},
  location        = {Albuquerque, New Mexico},
  pages           = {207--212},
  numpages        = 6,
  url             = {http://doi.acm.org/10.1145/582153.582176},
  doi             = {10.1145/582153.582176},
  acmid           = 582176,
  publisher       = {ACM},
  address         = {New York, NY, USA},
}

@inproceedings{Diehl:2014:GCE:2633628.2633630,
  author          = {Diehl, Larry and Sheard, Tim},
  title           = {Generic Constructors and Eliminators from Descriptions:
                  Type Theory As a Dependently Typed Internal DSL},
  booktitle       = {Proceedings of the 10th ACM SIGPLAN Workshop on Generic
                  Programming},
  series          = {WGP '14},
  year            = 2014,
  isbn            = {978-1-4503-3042-8},
  location        = {Gothenburg, Sweden},
  pages           = {3--14},
  numpages        = 12,
  url             = {http://doi.acm.org/10.1145/2633628.2633630},
  doi             = {10.1145/2633628.2633630},
  acmid           = 2633630,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {dependent types, descriptions, eliminators, generic
                  programming},
}

@InProceedings{Dunfield17:extensible,
  author          = {Joshua Dunfield},
  title           = {Extensible Datasort Refinements},
  booktitle       = {European Symposium on Programming (ESOP '17)},
  year            = 2017,
  month           = apr
}

@inproceedings{Dunfield:2003:TAI:1754809.1754827,
  author          = {Dunfield, Joshua and Pfenning, Frank},
  title           = {Type Assignment for Intersections and Unions in
                  Call-by-value Languages},
  booktitle       = {Proceedings of the 6th International Conference on
                  Foundations of Software Science and Computation Structures and
                  Joint European Conference on Theory and Practice of Software},
  series          = {FOSSACS'03/ETAPS'03},
  year            = 2003,
  isbn            = {3-540-00897-7},
  location        = {Warsaw, Poland},
  pages           = {250--266},
  numpages        = 17,
  url             = {http://dl.acm.org/citation.cfm?id=1754809.1754827},
  acmid           = 1754827,
  publisher       = {Springer-Verlag},
  address         = {Berlin, Heidelberg},
}

@inproceedings{Dunfield:2004:TT:964001.964025,
  author          = {Dunfield, Joshua and Pfenning, Frank},
  title           = {Tridirectional Typechecking},
  booktitle       = {Proceedings of the 31st ACM SIGPLAN-SIGACT Symposium on
                  Principles of Programming Languages},
  series          = {POPL '04},
  year            = 2004,
  isbn            = {1-58113-729-X},
  location        = {Venice, Italy},
  pages           = {281--292},
  numpages        = 12,
  url             = {http://doi.acm.org/10.1145/964001.964025},
  doi             = {10.1145/964001.964025},
  acmid           = 964025,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {dependent types, intersection types, type refinements,
                  union types},
}

@inproceedings{Dunfield:2007:RTS:1292597.1292602,
  author          = {Dunfield, Joshua},
  title           = {Refined Typechecking with Stardust},
  booktitle       = {Proceedings of the 2007 Workshop on Programming Languages
                  Meets Program Verification},
  series          = {PLPV '07},
  year            = 2007,
  isbn            = {978-1-59593-677-6},
  location        = {Freiburg, Germany},
  pages           = {21--32},
  numpages        = 12,
  url             = {http://doi.acm.org/10.1145/1292597.1292602},
  doi             = {10.1145/1292597.1292602},
  acmid           = 1292602,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {dependent types, intersection types, type refinements,
                  union types},
}



[download]
}

@inproceedings{Dunfield:2012:EIU:2364527.2364534,
  author          = {Dunfield, Joshua},
  title           = {Elaborating Intersection and Union Types},
  booktitle       = {Proceedings of the 17th ACM SIGPLAN International
                  Conference on Functional Programming},
  series          = {ICFP '12},
  year            = 2012,
  isbn            = {978-1-4503-1054-3},
  location        = {Copenhagen, Denmark},
  pages           = {17--28},
  numpages        = 12,
  url             = {http://doi.acm.org/10.1145/2364527.2364534},
  doi             = {10.1145/2364527.2364534},
  acmid           = 2364534,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {intersection types},
}

@Article{Dybjer1994,
  author          = "Dybjer, Peter",
  title           = "Inductive families",
  journal         = "Formal Aspects of Computing",
  year            = 1994,
  month           = "Jul",
  day             = 01,
  volume          = 6,
  number          = 4,
  pages           = "440--465",
  abstract        = "A general formulation of inductive and recursive
                  definitions in Martin-L{\"o}f's type theory is presented. It
                  extends Backhouse's `Do-It-Yourself Type Theory' to include
                  inductive definitions of families of sets and definitions of
                  functions by recursion on the way elements of such sets are
                  generated. The formulation is in natural deduction and is
                  intended to be a natural generalisation to type theory of
                  Martin-L{\"o}f's theory of iterated inductive definitions in
                  predicate logic.",
  issn            = "1433-299X",
  doi             = "10.1007/BF01211308",
  url             = "https://doi.org/10.1007/BF01211308"
}

@inproceedings{Dybvig:2006:DCS:1159803.1159805,
  author          = {Dybvig, R. Kent},
  title           = {The Development of Chez Scheme},
  booktitle       = {Proceedings of the Eleventh ACM SIGPLAN International
                  Conference on Functional Programming},
  series          = {ICFP '06},
  year            = 2006,
  isbn            = {1-59593-309-3},
  location        = {Portland, Oregon, USA},
  pages           = {1--12},
  numpages        = 12,
  url             = {http://doi.acm.org/10.1145/1159803.1159805},
  doi             = {10.1145/1159803.1159805},
  acmid           = 1159805,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {chez scheme, scheme implementation},
}

@Inproceedings{EPTCS153.4,
  author          = {Abel, Andreas and Chapman, James},
  year            = 2014,
  title           = {Normalization by Evaluation in the Delay Monad: A Case
                  Study for Coinduction via Copatterns and Sized Types},
  editor          = {Levy, Paul and Krishnaswami, Neel },
  booktitle       = {{\rm Proceedings 5th Workshop on} Mathematically Structured
                  Functional Programming, {\rm Grenoble, France, 12 April 2014}},
  series          = {Electronic Proceedings in Theoretical Computer Science},
  volume          = 153,
  publisher       = {Open Publishing Association},
  pages           = {51-67},
  doi             = {10.4204/EPTCS.153.4},
}

@Inproceedings{EPTCS76.9,
  author          = {Sj\"oberg, Vilhelm and Casinghino, Chris and Ahn, Ki Yung
                  and Collins, Nathan and Eades III, Harley D. and Fu, Peng and
                  Kimmell, Garrin and Sheard, Tim and Stump, Aaron and Weirich,
                  Stephanie},
  year            = 2012,
  title           = {Irrelevance, Heterogeneous Equality, and Call-by-value
                  Dependent Type Systems},
  editor          = {Chapman, James and Levy, Paul Blain},
  booktitle       = {{\rm Proceedings Fourth Workshop on} Mathematically
                  Structured Functional Programming, {\rm Tallinn, Estonia, 25
                  March 2012}},
  series          = {Electronic Proceedings in Theoretical Computer Science},
  volume          = 76,
  publisher       = {Open Publishing Association},
  pages           = {112-162},
  doi             = {10.4204/EPTCS.76.9},
}

@article{Eremondi:2019:ANG:3352468.3341692,
  author          = {Eremondi, Joseph and Tanter, \'{E}ric and Garcia, Ronald},
  title           = {Approximate Normalization for Gradual Dependent Types},
  journal         = {Proc. ACM Program. Lang.},
  issue_date      = {August 2019},
  volume          = 3,
  number          = {ICFP},
  month           = jul,
  year            = 2019,
  issn            = {2475-1421},
  pages           = {88:1--88:30},
  articleno       = 88,
  numpages        = 30,
  url             = {http://doi.acm.org/10.1145/3341692},
  doi             = {10.1145/3341692},
  acmid           = 3341692,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {Gradual types, dependent types, normalization},
}

@inproceedings{Findler:2002:CHF:581478.581484,
  author          = {Findler, Robert Bruce and Felleisen, Matthias},
  title           = {Contracts for Higher-order Functions},
  booktitle       = {Proceedings of the Seventh ACM SIGPLAN International
                  Conference on Functional Programming},
  series          = {ICFP '02},
  year            = 2002,
  isbn            = {1-58113-487-8},
  location        = {Pittsburgh, PA, USA},
  pages           = {48--59},
  numpages        = 12,
  url             = {http://doi.acm.org/10.1145/581478.581484},
  doi             = {10.1145/581478.581484},
  acmid           = 581484,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {behavioral specifications, contracts, higher-order
                  functions, predicate typing, solfware reliability},
}

@inproceedings{Freeman:1991:RTM:113445.113468,
  author          = {Freeman, Tim and Pfenning, Frank},
  title           = {Refinement Types for ML},
  booktitle       = {Proceedings of the ACM SIGPLAN 1991 Conference on
                  Programming Language Design and Implementation},
  series          = {PLDI '91},
  year            = 1991,
  isbn            = {0-89791-428-7},
  location        = {Toronto, Ontario, Canada},
  pages           = {268--277},
  numpages        = 10,
  url             = {http://doi.acm.org.ezproxy.library.ubc.ca/10.1145/113445.113468},
  doi             = {10.1145/113445.113468},
  acmid           = 113468,
  publisher       = {ACM},
  address         = {New York, NY, USA},
}

@misc{GDTL-github,
  author          = {Eremondi, Joseph},
  title           = {Github Repository: GDTL-artifact},
  year            = 2019,
  publisher       = {GitHub},
  journal         = {GitHub repository},
  howpublished    = {\url{https://github.com/JoeyEremondi/GDTL-artifact/}},
}

@inproceedings{Garcia:2015:PTS:2676726.2676992,
  author          = {Garcia, Ronald and Cimini, Matteo},
  title           = {Principal Type Schemes for Gradual Programs},
  booktitle       = {Proceedings of the 42Nd Annual ACM SIGPLAN-SIGACT Symposium
                  on Principles of Programming Languages},
  series          = {POPL '15},
  year            = 2015,
  isbn            = {978-1-4503-3300-9},
  location        = {Mumbai, India},
  pages           = {303--315},
  numpages        = 13,
  url             = {http://doi.acm.org/10.1145/2676726.2676992},
  doi             = {10.1145/2676726.2676992},
  acmid           = 2676992,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {gradual typing, type inference},
}

@Inbook{Goguen2006,
  author          = "Goguen, Healfdene and McBride, Conor and McKinna, James",
  editor          = "Futatsugi, Kokichi and Jouannaud, Jean-Pierre and Meseguer,
                  Jos{\'e}",
  title           = "Eliminating Dependent Pattern Matching",
  bookTitle       = "Algebra, Meaning, and Computation: Essays dedicated to
                  Joseph A. Goguen on the Occasion of His 65th Birthday",
  year            = 2006,
  publisher       = "Springer Berlin Heidelberg",
  address         = "Berlin, Heidelberg",
  pages           = "521--540",
  isbn            = "978-3-540-35464-2",
  doi             = "10.1007/11780274_27",
  url             = "https://doi.org/10.1007/11780274_27"
}

@article{Greenman:2018:STS:3243631.3236766,
  author          = {Greenman, Ben and Felleisen, Matthias},
  title           = {A Spectrum of Type Soundness and Performance},
  journal         = {Proc. ACM Program. Lang.},
  issue_date      = {September 2018},
  volume          = 2,
  number          = {ICFP},
  month           = jul,
  year            = 2018,
  issn            = {2475-1421},
  pages           = {71:1--71:32},
  articleno       = 71,
  numpages        = 32,
  url             = {http://doi.acm.org/10.1145/3236766},
  doi             = {10.1145/3236766},
  acmid           = 3236766,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {D-deliverable, migratory typing, performance evaluation,
                  type soundness},
}

@article{HUET1973257,
  title           = "The undecidability of unification in third order logic",
  journal         = "Information and Control",
  volume          = 22,
  number          = 3,
  pages           = "257 - 267",
  year            = 1973,
  issn            = "0019-9958",
  doi             = "10.1016/S0019-9958(73)90301-X",
  url             = "http://www.sciencedirect.com/science/article/pii/S001999587390301X",
  author          = "Gerard P. Huet"
}

@article{HUET197527,
  title           = "A unification algorithm for typed $\lambda$-calculus",
  journal         = "Theoretical Computer Science",
  volume          = 1,
  number          = 1,
  pages           = "27 - 57",
  year            = 1975,
  issn            = "0304-3975",
  doi             = "10.1016/0304-3975(75)90011-0",
  url             = "http://www.sciencedirect.com/science/article/pii/0304397575900110",
  author          = "G.P. Huet"
}

@article{Harper:1993:FDL:138027.138060,
  author          = {Harper, Robert and Honsell, Furio and Plotkin, Gordon},
  title           = {A Framework for Defining Logics},
  journal         = {J. ACM},
  issue_date      = {Jan. 1993},
  volume          = 40,
  number          = 1,
  month           = jan,
  year            = 1993,
  issn            = {0004-5411},
  pages           = {143--184},
  numpages        = 42,
  url             = {http://doi.acm.org/10.1145/138027.138060},
  doi             = {10.1145/138027.138060},
  acmid           = 138060,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {formal systems, interactive theorem proving, proof
                  checking, typed lambda calculus},
}

@inproceedings{Heintze:1994:SAM:182409.182495,
  author          = {Heintze, Nevin},
  title           = {Set-based Analysis of ML Programs},
  booktitle       = {Proceedings of the 1994 ACM Conference on LISP and
                  Functional Programming},
  series          = {LFP '94},
  year            = 1994,
  isbn            = {0-89791-643-3},
  location        = {Orlando, Florida, USA},
  pages           = {306--317},
  numpages        = 12,
  url             = {http://doi.acm.org/10.1145/182409.182495},
  doi             = {10.1145/182409.182495},
  acmid           = 182495,
  publisher       = {ACM},
  address         = {New York, NY, USA},
}

@misc{Idris2-github,
  author          = {Brady, Edwin},
  title           = {Github Repository: Idris 2},
  year            = 2019,
  publisher       = {GitHub},
  journal         = {GitHub repository},
  howpublished    = {\url{https://github.com/edwinb/Idris2}},
}

@inproceedings{Koot:2015:TEA:2678015.2682542,
  author          = {Koot, Ruud and Hage, Jurriaan},
  title           = {Type-based Exception Analysis for Non-strict Higher-order
                  Functional Languages with Imprecise Exception Semantics},
  booktitle       = {Proceedings of the 2015 Workshop on Partial Evaluation and
                  Program Manipulation},
  series          = {PEPM '15},
  year            = 2015,
  isbn            = {978-1-4503-3297-2},
  location        = {Mumbai, India},
  pages           = {127--138},
  numpages        = 12,
  url             = {http://doi.acm.org/10.1145/2678015.2682542},
  doi             = {10.1145/2678015.2682542},
  acmid           = 2682542,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {exception analysis, imprecise exceptions, pattern-matching,
                  type-based program analysis},
}

@inproceedings{lehmannTanter:popl2017,
  author          = {Lehmann, Nico and Tanter, \'{E}ric},
  title           = {Gradual Refinement Types},
  booktitle       = {Proceedings of the 44th ACM SIGPLAN Symposium on Principles
                  of Programming Languages},
  series          = {POPL 2017},
  year            = 2017,
  isbn            = {978-1-4503-4660-3},
  location        = {Paris, France},
  pages           = {775--788},
  numpages        = 14,
  url             = {http://doi.acm.org/10.1145/3009837.3009856},
  doi             = {10.1145/3009837.3009856},
  acmid           = 3009856,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {abstract interpretation, gradual typing, refinement types},
}

@Article{Lowenheim1915,
  author          = "L{\"o}wenheim, Leopold",
  title           = "{\"U}ber M{\"o}glichkeiten im Relativkalk{\"u}l",
  journal         = "Mathematische Annalen",
  year            = 1915,
  month           = "Dec",
  day             = 01,
  volume          = 76,
  number          = 4,
  pages           = "447--470",
  issn            = "1432-1807",
  doi             = "10.1007/BF01458217",
  url             = "https://doi.org/10.1007/BF01458217"
}

@incollection{MARTINLOUF197581,
  title           = "About Models for Intuitionistic Type Theories and the
                  Notion of Definitional Equality",
  editor          = "Stig Kanger",
  series          = "Studies in Logic and the Foundations of Mathematics",
  publisher       = "Elsevier",
  volume          = 82,
  pages           = "81 - 109",
  year            = 1975,
  booktitle       = "Proceedings of the Third Scandinavian Logic Symposium",
  issn            = "0049-237X",
  doi             = "10.1016/S0049-237X(08)70727-4",
  url             = "http://www.sciencedirect.com/science/article/pii/S0049237X08707274",
  author          = "Per Martin-L{\"o}f"
}

@article{MillerUnif,
  author          = {Miller, Dale},
  title           = {Unification Under a Mixed Prefix},
  journal         = {J. Symb. Comput.},
  issue_date      = {Oct. 1992},
  volume          = 14,
  number          = 4,
  month           = oct,
  year            = 1992,
  issn            = {0747-7171},
  pages           = {321--358},
  numpages        = 38,
  url             = {http://dx.doi.org/10.1016/0747-7171(92)90011-R},
  doi             = {10.1016/0747-7171(92)90011-R},
  acmid           = 147067,
  publisher       = {Academic Press, Inc.},
  address         = {Duluth, MN, USA},
}

@article{Nanevski:2008:CMT:1352582.1352591,
  author          = {Nanevski, Aleksandar and Pfenning, Frank and Pientka,
                  Brigitte},
  title           = {Contextual Modal Type Theory},
  journal         = {ACM Trans. Comput. Logic},
  issue_date      = {June 2008},
  volume          = 9,
  number          = 3,
  month           = jun,
  year            = 2008,
  issn            = {1529-3785},
  pages           = {23:1--23:49},
  articleno       = 23,
  numpages        = 49,
  url             = {http://doi.acm.org/10.1145/1352582.1352591},
  doi             = {10.1145/1352582.1352591},
  acmid           = 1352591,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {Type theory, intuitionistic modal logic, logical
                  frameworks},
}

@inproceedings{Nielson:1999:TES:646005.673740,
  author          = {Nielson, Flemming and Nielson, Hanne Riis},
  title           = {Type and Effect Systems},
  booktitle       = {Correct System Design, Recent Insight and Advances, (to
                  Hans Langmaack on the Occasion of His Retirement from His
                  Professorship at the University of Kiel)},
  year            = 1999,
  isbn            = {3-540-66624-9},
  pages           = {114--136},
  numpages        = 23,
  url             = {http://dl.acm.org/citation.cfm?id=646005.673740},
  acmid           = 673740,
  publisher       = {Springer-Verlag},
  address         = {Berlin, Heidelberg},
}

@book{Nielson:2010:PPA:1965094,
  author          = {Nielson, Flemming and Nielson, Hanne R. and Hankin, Chris},
  title           = {Principles of Program Analysis},
  year            = 2010,
  isbn            = {3642084745, 9783642084744},
  publisher       = {Springer Publishing Company, Incorporated},
}

@inproceedings{Osera:2012:DI:2103776.2103779,
  author          = {Osera, Peter-Michael and Sj\"{o}berg, Vilhelm and
                  Zdancewic, Steve},
  title           = {Dependent Interoperability},
  booktitle       = {Proceedings of the Sixth Workshop on Programming Languages
                  Meets Program Verification},
  series          = {PLPV '12},
  year            = 2012,
  isbn            = {978-1-4503-1125-0},
  location        = {Philadelphia, Pennsylvania, USA},
  pages           = {3--14},
  numpages        = 12,
  url             = {http://doi.acm.org/10.1145/2103776.2103779},
  doi             = {10.1145/2103776.2103779},
  acmid           = 2103779,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {contracts, dependent types, language interoperability},
}

@article{PAVIOTTI2015333,
  title           = "A Model of PCF in Guarded Type Theory",
  journal         = "Electronic Notes in Theoretical Computer Science",
  volume          = 319,
  pages           = "333 - 349",
  year            = 2015,
  note            = "The 31st Conference on the Mathematical Foundations of
                  Programming Semantics (MFPS XXXI).",
  issn            = "1571-0661",
  doi             = "https://doi.org/10.1016/j.entcs.2015.12.020",
  url             = "http://www.sciencedirect.com/science/article/pii/S1571066115000870",
  author          = "Marco Paviotti and Rasmus Ejlers Møgelberg and Lars
                  Birkedal",
  keywords        = "Denotational semantics, guarded recursion, type theory,
                  PCF, synthetic domain theory",
  abstract        = "Guarded recursion is a form of recursion where recursive
                  calls are guarded by delay modalities. Previous work has shown
                  how guarded recursion is useful for constructing logics for
                  reasoning about programming languages with advanced features,
                  as well as for constructing and reasoning about elements of
                  coinductive types. In this paper we investigate how type
                  theory with guarded recursion can be used as a metalanguage
                  for denotational semantics useful both for constructing models
                  and for proving properties of these. We do this by
                  constructing a fairly intensional model of PCF and proving it
                  computationally adequate. The model construction is related to
                  Escardo's metric model for PCF, but here everything is carried
                  out entirely in type theory with guarded recursion, including
                  the formulation of the operational semantics, the model
                  construction and the proof of adequacy."
}

@article{PFENNING200084,
  title           = "Structural Cut Elimination: I. Intuitionistic and Classical
                  Logic",
  journal         = "Information and Computation",
  volume          = 157,
  number          = 1,
  pages           = "84 - 141",
  year            = 2000,
  issn            = "0890-5401",
  doi             = "https://doi.org/10.1006/inco.1999.2832",
  url             = "http://www.sciencedirect.com/science/article/pii/S0890540199928328",
  author          = "Frank Pfenning",
  abstract        = "We present new variants of known proofs of cut elimination
                  for intuitionistic and classical sequent calculi. In both
                  cases the proofs proceed by three nested structural
                  inductions, avoiding the explicit use of multi-sets and
                  termination measures on sequent derivations. This makes them
                  amenable to elegant and concise representations in LF, which
                  are given in full detail."
}

@inproceedings{Pavlinovic15practical,
  author          = {Pavlinovic, Zvonimir and King, Tim and Wies, Thomas},
  title           = {Practical {SMT}-based Type Error Localization},
  booktitle       = {Proceedings of the 20th ACM SIGPLAN International
                  Conference on Functional Programming},
  series          = {ICFP 2015},
  year            = 2015,
  isbn            = {978-1-4503-3669-7},
  location        = {Vancouver, BC, Canada},
  pages           = {412--423},
  numpages        = 12,
  url             = {http://doi.acm.org/10.1145/2784731.2784765},
  doi             = {10.1145/2784731.2784765},
  acmid           = 2784765,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {Polymorphic Types, Satisfiability Modulo Theories, Type
                  Error Localization},
}

@InProceedings{ett,
author="P{\'e}drot, Pierre-Marie
and Tabareau, Nicolas",
editor="Ahmed, Amal",
title="Failure is Not an Option",
booktitle="Programming Languages and Systems",
year="2018",
publisher="Springer International Publishing",
address="Cham",
pages="245--271",
abstract="We define the exceptional translation, a syntactic translation of the Calculus of Inductive Constructions (CIC) into itself, that covers full dependent elimination. The new resulting type theory features call-by-name exceptions with decidable type-checking and canonicity, but at the price of inconsistency. Then, noticing parametricity amounts to Kreisel's realizability in this setting, we provide an additional layer on top of the exceptional translation in order to tame exceptions and ensure that all exceptions used locally are caught, leading to the parametric exceptional translation which fully preserves consistency. This way, we can consistently extend the logical expressivity of CIC with independence of premises, Markov's rule, and the negation of function extensionality while retaining $\eta$-expansion. As a byproduct, we also show that Markov's principle is not provable in CIC. Both translations have been implemented in a Coq plugin, which we use to formalize the examples.",
isbn="978-3-319-89884-1"
}


@article{Pedrot:2019:RET:3352468.3341712,
  author          = {P{\'e}drot, Pierre-Marie and Tabareau, Nicolas and
                  Fehrmann, Hans Jacob and Tanter, \'{E}ric},
  title           = {A Reasonably Exceptional Type Theory},
  journal         = {Proc. ACM Program. Lang.},
  issue_date      = {August 2019},
  volume          = 3,
  number          = {ICFP},
  month           = jul,
  year            = 2019,
  issn            = {2475-1421},
  pages           = {108:1--108:29},
  articleno       = 108,
  numpages        = 29,
  url             = {http://doi.acm.org/10.1145/3341712},
  doi             = {10.1145/3341712},
  acmid           = 3341712,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {effects, exceptions, parametricity, type theory},
}

@inproceedings{Pientka:2008:PPE:1389449.1389469,
  author          = {Pientka, Brigitte and Dunfield, Joshua},
  title           = {Programming with Proofs and Explicit Contexts},
  booktitle       = {Proceedings of the 10th International ACM SIGPLAN
                  Conference on Principles and Practice of Declarative
                  Programming},
  series          = {PPDP '08},
  year            = 2008,
  isbn            = {978-1-60558-117-0},
  location        = {Valencia, Spain},
  pages           = {163--173},
  numpages        = 11,
  url             = {http://doi.acm.org.ezproxy.library.ubc.ca/10.1145/1389449.1389469},
  doi             = {10.1145/1389449.1389469},
  acmid           = 1389469,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {dependent types, logical frameworks, type theory},
}

@article{Pottier:2000:VCT:763845.763849,
  author          = {Pottier, Fran\c{c}ois},
  title           = {A Versatile Constraint-based Type Inference System},
  journal         = {Nordic J. of Computing},
  issue_date      = {Winter 2000},
  volume          = 7,
  number          = 4,
  month           = dec,
  year            = 2000,
  issn            = {1236-6064},
  pages           = {312--347},
  numpages        = 36,
  url             = {http://dl.acm.org/citation.cfm?id=763845.763849},
  acmid           = 763849,
  publisher       = {Publishing Association Nordic Journal of Computing},
  address         = {Finland},
  keywords        = {conditional constraints, constraint-based type inference,
                  rows, subtyping},
}

@inproceedings{Reynolds:1974:TTT:647323.721503,
  author          = {Reynolds, John C.},
  title           = {Towards a Theory of Type Structure},
  booktitle       = {Programming Symposium, Proceedings Colloque Sur La
                  Programmation},
  year            = 1974,
  isbn            = {3-540-06859-7},
  pages           = {408--423},
  numpages        = 16,
  url             = {http://dl.acm.org/citation.cfm?id=647323.721503},
  acmid           = 721503,
  publisher       = {Springer-Verlag},
  address         = {Berlin, Heidelberg},
}

@inproceedings{Rondon:2008:LT:1375581.1375602,
  author          = {Rondon, Patrick M. and Kawaguci, Ming and Jhala, Ranjit},
  title           = {Liquid Types},
  booktitle       = {Proceedings of the 29th ACM SIGPLAN Conference on
                  Programming Language Design and Implementation},
  series          = {PLDI '08},
  year            = 2008,
  isbn            = {978-1-59593-860-2},
  location        = {Tucson, AZ, USA},
  pages           = {159--169},
  numpages        = 11,
  url             = {http://doi.acm.org/10.1145/1375581.1375602},
  doi             = {10.1145/1375581.1375602},
  acmid           = 1375602,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {dependent types, hindley-milner, predicate abstraction,
                  type inference},
}

@article{SHEARD2007105,
  title           = "Type-level Computation Using Narrowing in $\Omega$mega",
  journal         = "Electronic Notes in Theoretical Computer Science",
  volume          = 174,
  number          = 7,
  pages           = "105 - 128",
  year            = 2007,
  note            = "Proceedings of the Programming Languages meets Program
                  Verification (PLPV 2006)",
  issn            = "1571-0661",
  doi             = "https://doi.org/10.1016/j.entcs.2006.10.040",
  url             = "http://www.sciencedirect.com/science/article/pii/S1571066107002551",
  author          = "Tim Sheard",
  keywords        = "Programming languages, logical systems, theorem provers,
                  narrowing, Curry-Howard isomorphism"
}

@phdthesis{girard1972interpretation,
  title={Interpr{\'e}tation fonctionelle et {\'e}limination des coupures de l’arithm{\'e}tique d’ordre sup{\'e}rieur},
  author={Girard, Jean-Yves},
  year={1972},
  school={PhD thesis, Universit{\'e} Paris VII}
}

@misc{SHErrLocWebsite,
  title           = {{SHErrLoc} Project},
  year            = 2016,
  howpublished    = {\url{http://www.cs.cornell.edu/projects/SHErrLoc/}},
  note            = {Accessed: 2015-12-16}
}

@inproceedings{Sekiyama:2015:MCD:2676726.2676996,
  author          = {Sekiyama, Taro and Nishida, Yuki and Igarashi, Atsushi},
  title           = {Manifest Contracts for Datatypes},
  booktitle       = {Proceedings of the 42Nd Annual ACM SIGPLAN-SIGACT Symposium
                  on Principles of Programming Languages},
  series          = {POPL '15},
  year            = 2015,
  isbn            = {978-1-4503-3300-9},
  location        = {Mumbai, India},
  pages           = {195--207},
  numpages        = 13,
  url             = {http://doi.acm.org.ezproxy.library.ubc.ca/10.1145/2676726.2676996},
  doi             = {10.1145/2676726.2676996},
  acmid           = 2676996,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {algebraic datatypes, contract checking, datatype
                  translation, refinement types},
}

@inproceedings{Siek:2009:TWB:1570506.1570511,
  author          = {Siek, Jeremy G. and Wadler, Philip},
  title           = {Threesomes, with and Without Blame},
  booktitle       = {Proceedings of the 37th Annual ACM SIGPLAN-SIGACT Symposium
                  on Principles of Programming Languages},
  series          = {POPL '10},
  year            = 2010,
  isbn            = {978-1-60558-479-9},
  location        = {Madrid, Spain},
  pages           = {365--376},
  numpages        = 12,
  url             = {http://doi.acm.org/10.1145/1706299.1706342},
  doi             = {10.1145/1706299.1706342},
  acmid           = 1706342,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {blame tracking, casts, coercions, lambda-calculus},
}

@article{TAKAHASHI1995120,
  title           = {Parallel Reductions in $\lambda$-Calculus},
  journal         = {Information and Computation},
  volume          = 118,
  number          = 1,
  pages           = {120-127},
  year            = 1995,
  issn            = {0890-5401},
  doi             = {https://doi.org/10.1006/inco.1995.1057},
  url             = {https://www.sciencedirect.com/science/article/pii/S0890540185710577},
  author          = {M. Takahashi},
  abstract        = {The notion of parallel reduction is extracted from the
                  simple proof of the Church-Rosser theorem by Tait and
                  Martin-Löf. Intuitively, this means to reduce a number of
                  redexes (existing in a $\lambda$-term) simultaneously. Thus in the
                  case of β-reduction the effect of a parallel reduction is same
                  as that of a "complete development" which is defined by using
                  "residuals" of β-redexes. A nice feature of parallel
                  reduction, however, is that it can be defined directly by
                  induction on the structure of $\lambda$-terms (without referring to
                  residuals or other auxiliary notions), and the inductive
                  definition provides us exactly what we need in proving the
                  theorem inductively. Moreover, the notion can be easily
                  extended to other reduction systems such as Girard′s
                  second-order system F and Gödel′s system T. In this paper,
                  after reevaluating the significance of the notion of parallel
                  reduction in Tait-and-Martin-Löf type proofs of the
                  Church-Rosser theorems, we show that the notion of parallel
                  reduction is also useful in giving short and direct proofs of
                  some other fundamental theorems in reduction theory of
                  $\lambda$-calculus; among others, we give such simple proofs of the
                  standardization theorem for β-reduction (a special case of
                  which is known as the leftmost reduction theorem for
                  β-reduction), the quasi-leftmost reduction theorem for
                  β-reduction, the postponement theorem of η-reduction (in
                  βη-reduction), and the leftmost reduction theorem for
                  βη-reduction.}
}

@inproceedings{Takikawa:2012:GTF:2384616.2384674,
  author          = {Takikawa, Asumu and Strickland, T. Stephen and Dimoulas,
                  Christos and Tobin-Hochstadt, Sam and Felleisen, Matthias},
  title           = {Gradual Typing for First-class Classes},
  booktitle       = {Proceedings of the ACM International Conference on Object
                  Oriented Programming Systems Languages and Applications},
  series          = {OOPSLA '12},
  year            = 2012,
  isbn            = {978-1-4503-1561-6},
  location        = {Tucson, Arizona, USA},
  pages           = {793--810},
  numpages        = 18,
  url             = {http://doi.acm.org/10.1145/2384616.2384674},
  doi             = {10.1145/2384616.2384674},
  acmid           = 2384674,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {blame theorem (proof technique), contracts, design by
                  contract, first-class classes, gradual typing, row
                  polymorphism, sealing},
}

@inproceedings{Tanter:2015:GCP:2816707.2816710,
  author          = {Tanter, \'{E}ric and Tabareau, Nicolas},
  title           = {Gradual Certified Programming in Coq},
  booktitle       = {Proceedings of the 11th Symposium on Dynamic Languages},
  series          = {DLS 2015},
  year            = 2015,
  isbn            = {978-1-4503-3690-1},
  location        = {Pittsburgh, PA, USA},
  pages           = {26--40},
  numpages        = 15,
  url             = {http://doi.acm.org/10.1145/2816707.2816710},
  doi             = {10.1145/2816707.2816710},
  acmid           = 2816710,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {Certified programming, Coq, casts, gradual typing, program
                  extraction, refinements, subset types},
}

@Inbook{Tseitin1983,
  author          = "Tseitin, G. S.",
  editor          = "Siekmann, J{\"o}rg H. and Wrightson, Graham",
  title           = "On the Complexity of Derivation in Propositional Calculus",
  bookTitle       = "Automation of Reasoning: 2: Classical Papers on
                  Computational Logic 1967--1970",
  year            = 1983,
  publisher       = "Springer Berlin Heidelberg",
  address         = "Berlin, Heidelberg",
  pages           = "466--483",
  abstract        = "The question of the minimum complexity of derivation of a
                  given formula in classical propositional calculus is
                  considered in this article and it is proved that estimates of
                  complexity may vary considerably among the various forms of
                  propositional calculus. The forms of propositional calculus
                  used in the present article are somewhat unusual,
                  {\textdagger} but the results obtained for them can, in
                  principle, be extended to the usual forms of propositional
                  calculus.",
  isbn            = "978-3-642-81955-1",
  doi             = "10.1007/978-3-642-81955-1_28",
  url             = "https://doi.org/10.1007/978-3-642-81955-1_28"
}

@inproceedings{Vazou:2014:RTH:2628136.2628161,
  author          = {Vazou, Niki and Seidel, Eric L. and Jhala, Ranjit and
                  Vytiniotis, Dimitrios and Peyton-Jones, Simon},
  title           = {Refinement Types for Haskell},
  booktitle       = {Proceedings of the 19th ACM SIGPLAN International
                  Conference on Functional Programming},
  series          = {ICFP '14},
  year            = 2014,
  isbn            = {978-1-4503-2873-9},
  location        = {Gothenburg, Sweden},
  pages           = {269--282},
  numpages        = 14,
  url             = {http://doi.acm.org/10.1145/2628136.2628161},
  doi             = {10.1145/2628136.2628161},
  acmid           = 2628161,
  publisher       = {ACM},
  address         = {New York, NY, USA},
}

@article{Vitousek:2017:BTL:3093333.3009849,
  author          = {Vitousek, Michael M. and Swords, Cameron and Siek, Jeremy
                  G.},
  title           = {Big Types in Little Runtime: Open-world Soundness and
                  Collaborative Blame for Gradual Type Systems},
  journal         = {SIGPLAN Not.},
  issue_date      = {January 2017},
  volume          = 52,
  number          = 1,
  month           = jan,
  year            = 2017,
  issn            = {0362-1340},
  pages           = {762--774},
  numpages        = 13,
  url             = {http://doi.acm.org/10.1145/3093333.3009849},
  doi             = {10.1145/3093333.3009849},
  acmid           = 3009849,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {gradual typing, interoperability, semantics, type systems},
}

@inproceedings{Xi1999,
  author          = {Xi, Hongwei and Pfenning, Frank},
  title           = {Dependent Types in Practical Programming},
  booktitle       = {Proceedings of the 26th ACM SIGPLAN-SIGACT Symposium on
                  Principles of Programming Languages},
  series          = {POPL '99},
  year            = 1999,
  isbn            = {1-58113-095-3},
  location        = {San Antonio, Texas, USA},
  pages           = {214--227},
  numpages        = 14,
  url             = {http://doi.acm.org/10.1145/292540.292560},
  doi             = {10.1145/292540.292560},
  acmid           = 292560,
  publisher       = {ACM},
  address         = {New York, NY, USA},
}

@misc{agdaMutRec,
  author          = { Ulf Norell et. al.},
  title           = {{Agda} Documentation},
  year            = 2016,
  howpublished    = {\url{http://agda.readthedocs.io/en/latest/language/mutual-recursion.html}}
}

@inproceedings{agdaPaper,
  author          = {Norell, Ulf},
  title           = {Dependently Typed Programming in {Agda}},
  booktitle       = {Proceedings of the 4th International Workshop on Types in
                  Language Design and Implementation},
  series          = {TLDI '09},
  year            = 2009,
  isbn            = {978-1-60558-420-1},
  location        = {Savannah, GA, USA},
  pages           = {1--2},
  numpages        = 2,
  url             = {http://doi.acm.org/10.1145/1481861.1481862},
  doi             = {10.1145/1481861.1481862},
  acmid           = 1481862,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {dependent types, programming},
}

@misc{agdaTerminate,
  title           = {{Agda} termination checker},
  year            = 2016,
  howpublished    = {\url{http://wiki.portal.chalmers.se/agda/pmwiki.php?n=ReferenceManual.TerminationChecker}},
  note            = {Accessed: 2016-02-03}
}


%added by bibpaste

@inproceedings{agt,
  author          = {Garcia, Ronald and Clark, Alison M. and Tanter, \'{E}ric},
  title           = {Abstracting Gradual Typing},
  booktitle       = {Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium
                  on Principles of Programming Languages},
  series          = {POPL '16},
  year            = 2016,
  isbn            = {978-1-4503-3549-2},
  location        = {St. Petersburg, FL, USA},
  pages           = {429--442},
  numpages        = 14,
  url             = {http://doi.acm.org/10.1145/2837614.2837670},
  doi             = {10.1145/2837614.2837670},
  acmid           = 2837670,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {abstract interpretation, gradual typing, subtyping},
}

%added by bibpaste

%added by bibpaste

@article{algoM,
  author          = {Lee, Oukseh and Yi, Kwangkeun},
  title           = {Proofs About a Folklore Let-polymorphic Type Inference
                  Algorithm},
  journal         = {ACM Trans. Program. Lang. Syst.},
  issue_date      = {July 1998},
  volume          = 20,
  number          = 4,
  month           = jul,
  year            = 1998,
  issn            = {0164-0925},
  pages           = {707--723},
  numpages        = 17,
  url             = {http://doi.acm.org/10.1145/291891.291892},
  doi             = {10.1145/291891.291892},
  acmid           = 291892,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {type error, type inference algorithm},
}

@article{curToAppear,
 author = { Stephen Chang and Michael Ballantyne and Milo Turner and William J. Bowman },
 title = {Dependent Type Systems as Macros},
 journal = {To appear in Proc. ACM Program. Lang.},
 issue_date = {January 2020},
 volume = {4},
 number = {POPL},
 month = jan,
 year = {2020},
 %issn = {2475-1421},
 %pages = {1:1--1:27},
 %articleno = {1},
 %numpages = {27},
 url = {https://www.williamjbowman.com/downloads/wjb-paper-depmacros.pdf},
 %doi = {10.1145/3290314},
 %acmid = {3290314},
 publisher = {ACM},
 address = {New York, NY, USA},
 %keywords = {cubical type theory, higher inductive types, homotopy type theory},
}

%added by bibpaste

@article{banadosAl:jfp2016,
  author          = {Ba{\~n}ados Schwerter, Felipe and Ronald Garcia and
                  {\'E}ric Tanter},
  title           = {Gradual Type-and-Effect Systems},
  journal         = jfp,
  year            = 2016,
  pages           = {19:1--19:69},
  publisher       = cam,
  urlpdf          = {http://pleiad.dcc.uchile.cl/papers/2016/banadosAl-jfp2016.pdf},
  urldoi          = {http://dx.doi.org/10.1017/S0956796816000162},
  users           = { etanter },
  volume          = 26,
  month           = sep,
}
%added by bibpaste

@article{basicDepTutorial,
  author          = {L\"{o}h, Andres and McBride, Conor and Swierstra, Wouter},
  title           = {A Tutorial Implementation of a Dependently Typed Lambda
                  Calculus},
  journal         = {Fundam. Inf.},
  issue_date      = {April 2010},
  volume          = 102,
  number          = 2,
  month           = apr,
  year            = 2010,
  issn            = {0169-2968},
  pages           = {177--207},
  numpages        = 31,
  doi             = {10.3233/FI-2010-304},
  url             = {http://dl.acm.org/citation.cfm?id=1883634.1883637},
  acmid           = 1883637,
  publisher       = {IOS Press},
  address         = {Amsterdam, The Netherlands, The Netherlands},
}
%added by bibload


@phdthesis{lemayThesis,
  author  = "Lemay, Mark",
  title   = "A Dependently Typed Programming Language With Dynamic Equality",
  school  = "Boston University",
  year    = "2022",
  url = "https://github.com/marklemay/thesis"
}

@article{bertrand:gcic,
author = {Lennon-Bertrand, Meven and Maillard, Kenji and Tabareau, Nicolas and Tanter, \'{E}ric},
title = {Gradualizing the Calculus of Inductive Constructions},
year = {2022},
issue_date = {June 2022},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {44},
number = {2},
issn = {0164-0925},
url = {https://doi.org/10.1145/3495528},
doi = {10.1145/3495528},
abstract = {We investigate gradual variations on the Calculus of Inductive Construction (CIC) for swifter prototyping with imprecise types and terms. We observe, with a no-go theorem, a crucial trade-off between graduality and the key properties of normalization and closure of universes under dependent product that CIC enjoys. Beyond this Fire Triangle of Graduality, we explore the gradualization of CIC with three different compromises, each relaxing one edge of the Fire Triangle. We develop a parametrized presentation of Gradual CIC (GCIC) that encompasses all three variations, and develop their metatheory. We first present a bidirectional elaboration of GCIC to a dependently-typed cast calculus, CastCIC, which elucidates the interrelation between typing, conversion, and the gradual guarantees. We use a syntactic model of CastCIC to inform the design of a safe, confluent reduction, and establish, when applicable, normalization. We study the static and dynamic gradual guarantees as well as the stronger notion of graduality with embedding-projection pairs formulated by New and Ahmed, using appropriate semantic model constructions. This work informs and paves the way towards the development of malleable proof assistants and dependently-typed programming languages.},
journal = {ACM Trans. Program. Lang. Syst.},
month = {apr},
articleno = {7},
numpages = {82},
keywords = {Gradual typing, proof assistants, dependent types}
}




%added by bibpaste
@mastersthesis{turk2010modern,
  title={A modern back-end for a dependently typed language},
  author={Turk, Remi},
  year={2010},
  school={Universiteit van Amsterdam},
  url={https://www.illc.uva.nl/Research/Publications/Reports/MoL-2010-19.text.pdf}
}

%added by bibload


@InProceedings{birkedal_et_al:LIPIcs:2016:6563,
  author          = {Lars Birkedal and Ale{\v{s}} Bizjak and Ranald Clouston and
                  Hans Bugge Grathwohl and Bas Spitters and Andrea Vezzosi},
  title           = {{Guarded Cubical Type Theory: Path Equality for Guarded
                  Recursion}},
  booktitle       = {25th EACSL Annual Conference on Computer Science Logic (CSL
                  2016)},
  pages           = {23:1--23:17},
  series          = {Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN            = {978-3-95977-022-4},
  ISSN            = {1868-8969},
  year            = 2016,
  volume          = 62,
  editor          = {Jean-Marc Talbot and Laurent Regnier},
  publisher       = {Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
  address         = {Dagstuhl, Germany},
  URL             = {http://drops.dagstuhl.de/opus/volltexte/2016/6563},
  URN             = {urn:nbn:de:0030-drops-65638},
  doi             = {10.4230/LIPIcs.CSL.2016.23},
  annote          = {Keywords: Guarded Recursion, Dependent Type Theory, Cubical
                  Type Theory, Denotational Semantics, Homotopy Type Theory}
}

%added by bibpaste

@InProceedings{chen_et_al:LIPIcs:2016:6100,
  author          = {Sheng Chen and Martin Erwig and Eric Walkingshaw},
  title           = {{A Calculus for Variational Programming}},
  booktitle       = {30th European Conference on Object-Oriented Programming
                  (ECOOP 2016)},
  pages           = {6:1--6:28},
  series          = {Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN            = {978-3-95977-014-9},
  ISSN            = {1868-8969},
  year            = 2016,
  volume          = 56,
  editor          = {Shriram Krishnamurthi and Benjamin S. Lerner},
  publisher       = {Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
  address         = {Dagstuhl, Germany},
  URL             = {http://drops.dagstuhl.de/opus/volltexte/2016/6100},
  URN             = {urn:nbn:de:0030-drops-61005},
  doi             = {10.4230/LIPIcs.ECOOP.2016.6},
  annote          = {Keywords: Variational programming, variational types,
                  variability-aware analyses}
}


%added by bibpaste

@inproceedings{churchCurry,
  author          = {Pfenning, Frank},
  title           = {Church and Curry: Combining intrinsic and extrinisic
                  typing},
  Isbn            = {978-1-904987-70-3},
  Editor          = {Christoph Benzm{\"u}ller and Chad Brown and J{\"o}rg
                  Siekmann and Richard Statman},
  Publisher       = {College Publications},
  Series          = {Studies in Logic, Mathematical Logic and Foundations},
  booktitle       = {Reasoning in Simple Type Theory -- Festschrift in Honor of
                  {Peter B.~Andrews} on His 70th Birthday},
  Url             = {http://www.collegepublications.co.uk/logic/mlf/?00010},
  Year            = 2008
}


%added by bibpaste

@article{cockx_devriese_2018,
  title           = {Proof-relevant unification: Dependent pattern matching with
                  only the axioms of your type theory},
  volume          = 28,
  DOI             = {10.1017/S095679681800014X},
  journal         = {Journal of Functional Programming},
  publisher       = {Cambridge University Press},
  author          = {Cockx, Jesper and Devriese, Dominique},
  year            = 2018,
  pages           = {e12}
}
%added by bibpaste

@inproceedings{cockxunifiers,
  author          = {Cockx, Jesper and Devriese, Dominique and Piessens, Frank},
  title           = {Unifiers As Equivalences: Proof-relevant Unification of
                  Dependently Typed Data},
  booktitle       = {Proceedings of the 21st ACM SIGPLAN International
                  Conference on Functional Programming},
  series          = {ICFP 2016},
  year            = 2016,
  isbn            = {978-1-4503-4219-3},
  location        = {Nara, Japan},
  pages           = {270--283},
  numpages        = 14,
  url             = {http://doi.acm.org/10.1145/2951913.2951917},
  doi             = {10.1145/2951913.2951917},
  acmid           = 2951917,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {Agda, Dependent Types, Inductive Families, Type Theory,
                  Unification},
}

%added by bibpaste

@InProceedings{ccha,
  author          = {Cyril Cohen and Thierry Coquand and Simon Huber and Anders
                  M{\"o}rtberg},
  title           = {{Cubical Type Theory: A Constructive Interpretation of the
                  Univalence Axiom}},
  booktitle       = {21st International Conference on Types for Proofs and
                  Programs (TYPES 2015)},
  pages           = {5:1--5:34},
  series          = {Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN            = {978-3-95977-030-9},
  ISSN            = {1868-8969},
  year            = 2018,
  volume          = 69,
  editor          = {Tarmo Uustalu},
  publisher       = {Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
  address         = {Dagstuhl, Germany},
  URL             = {http://drops.dagstuhl.de/opus/volltexte/2018/8475},
  URN             = {urn:nbn:de:0030-drops-84754},
  doi             = {10.4230/LIPIcs.TYPES.2015.5},
  annote          = {Keywords: univalence axiom, dependent type theory, cubical
                  sets}
}

%added by bibpaste

@article{constraintBasedHelium,
  title           = {Constraint based type inferencing in {Helium} },
  author          = {Heeren, Bastiaan and Hage, Jurriaan and Swierstra, S
                  Doaitse},
  journal         = {Immediate Applications of Constraint Programming (ACP)},
  year            = 2003,
  pages           = 57
}
%added by bibpaste

@misc{coqSite,
  title           = {The {Coq} Theorem Prover},
  year            = 2016,
  howpublished    = {\url{https://coq.inria.fr/}},
  note            = {Accessed: 2016-01-27}
}


%added by bibpaste

@book{coqart,
  author          = {Yves Bertot and Pierre Cast{\'e}ran},
  title           = {Interactive Theorem Proving and Program Development},
  publisher       = sv,
  year            = 2004,
}
%added by bibpaste

@inproceedings{coquand1992pattern,
  title           = {Pattern matching with dependent types},
  author          = {Coquand, Thierry},
  booktitle       = {Informal proceedings of Logical Frameworks},
  volume          = 92,
  pages           = {66--79},
  year            = 1992
}
%added by bibpaste
 BibTeX | EndNote | ACM Ref

@inproceedings{counterFactual,
  author          = {Chen, Sheng and Erwig, Martin},
  title           = {Counter-factual Typing for Debugging Type Errors},
  booktitle       = {Proceedings of the 41st ACM SIGPLAN-SIGACT Symposium on
                  Principles of Programming Languages},
  series          = {POPL '14},
  year            = 2014,
  isbn            = {978-1-4503-2544-8},
  location        = {San Diego, California, USA},
  pages           = {583--594},
  numpages        = 12,
  url             = {http://doi.acm.org/10.1145/2535838.2535863},
  doi             = {10.1145/2535838.2535863},
  acmid           = 2535863,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {change suggestions, choice types, error localization, type
                  error messages, type inference, type-error debugging},
}


%added by bibpaste

@book{cpdt,
  author          = {Chlipala, Adam},
  title           = {Certified Programming with Dependent Types: A Pragmatic
                  Introduction to the {Coq} Proof Assistant},
  year            = 2013,
  isbn            = {0262026651, 9780262026659},
  publisher       = {The MIT Press},
}

%added by bibload

@article{curry1934functionality,
  title           = {Functionality in combinatory logic},
  author          = {Curry, Haskell B},
  journal         = {Proceedings of the National Academy of Sciences of the
                  United States of America},
  volume          = 20,
  number          = 11,
  pages           = 584,
  year            = 1934,
  publisher       = {National Academy of Sciences}
}

@article{dagand2017,
  title           = {The essence of ornaments},
  volume          = 27,
  DOI             = {10.1017/S0956796816000356},
  journal         = {Journal of Functional Programming},
  publisher       = {Cambridge University Press},
  author          = {DAGAND, PIERRE-EVARISTE},
  year            = 2017,
  pages           = {e9}
}



%added by bibload

@inproceedings{partialTypeEquiv,
  author          = {Dagand, Pierre-{\'E}variste and Nicolas Tabareau and
                  {\'Eric Tanter}},
  title           = {Partial Type Equivalences for Verified Dependent
                  Interoperability},
  crossref        = {icfp2016},
  pages           = {298--310},
  DOI = {10.1145/2951913.2951933}
}


%added by bibpaste

@article{dagandtabareautanter2018,
  title           = {Foundations of dependent interoperability},
  volume          = 28,
  DOI             = {10.1017/S0956796818000011},
  journal         = {Journal of Functional Programming},
  publisher       = {Cambridge University Press},
  author          = {Dagand, Pierre-{\'E}variste and Tabareau, Nicolas and
                  Tanter, {\'E}ric},
  year            = 2018,
  pages           = {e9}
}

%added by bibpaste

@inproceedings{damasMilner,
  author          = {Damas, Luis and Milner, Robin},
  title           = {Principal Type-schemes for Functional Programs},
  booktitle       = {Proceedings of the 9th ACM SIGPLAN-SIGACT Symposium on
                  Principles of Programming Languages},
  series          = {POPL '82},
  year            = 1982,
  isbn            = {0-89791-065-6},
  location        = {Albuquerque, New Mexico},
  pages           = {207--212},
  numpages        = 6,
  url             = {http://doi.acm.org/10.1145/582153.582176},
  doi             = {10.1145/582153.582176},
  acmid           = 582176,
  publisher       = {ACM},
  address         = {New York, NY, USA},
}




%added by bibpaste

@Proceedings{dls2008,
  key             = {DLS 2008},
  booktitle       = {Proceedings of the 4th {ACM} Dynamic Languages Symposium
                  (DLS 2008)},
  title           = {Proceedings of the 4th {ACM} Dynamic Languages Symposium
                  (DLS 2008)},
  year            = 2008,
  address         = {Paphos, Cyprus},
  month           = jul,
  publisher       = ACM,
}

%added by bibpaste

@inproceedings{eades2010hereditary,
  title           = {Hereditary substitution for stratified system {F} },
  author          = {Eades, Harley and Stump, Aaron},
  booktitle       = {International Workshop on Proof-Search in Type Theories,
                  PSTT},
  volume          = 10,
  year            = 2010
}





%added by bibload

@misc{eisenberg2016dependent,
  title           = {Dependent Types in Haskell: Theory and Practice},
  author          = {Richard A. Eisenberg},
  year            = 2016,
  eprint          = {1610.07978},
  archivePrefix   = {arXiv},
  primaryClass    = {cs.PL}
}

@inproceedings{empiricalErrorMessage,
  author          = {Barik, Titus and others},
  title           = {Do Developers Read Compiler Error Messages?},
  booktitle       = {Proceedings of the 39th International Conference on
                  Software Engineering},
  series          = {ICSE '17},
  year            = 2017,
  isbn            = {978-1-5386-3868-2},
  location        = {Buenos Aires, Argentina},
  pages           = {575--585},
  numpages        = 11,
  url             = {https://doi.org/10.1109/ICSE.2017.59},
  doi             = {10.1109/ICSE.2017.59},
  acmid           = 3097437,
  publisher       = {IEEE Press},
  address         = {Piscataway, NJ, USA},
  keywords        = {compiler errors, eye tracking, integrated development
                  environments, programmer comprehension, reading, visual
                  attention},
}

@misc{eremondi2019approximate-full,
  title           = {Approximate Normalization for Gradual Dependent Types},
  author          = {Joseph Eremondi and {\'E}ric Tanter and Ronald Garcia},
  year            = 2019,
  eprint          = {1906.06469},
  archivePrefix   = {arXiv}
}

@Article{eremondiSwierstraHage,
  author          = "Joseph Eremondi and Wouter Swierstra and Jurriaan Hage",
  title           = "A framework for improving error messages in dependently
                  typed languages",
  journal         = "Open Computer Science (to appear)",
  volume          = {Topical issue on type error diagnosis},
  year            = 2018
}

@inproceedings{errTolChoice,
  author          = {Chen, Sheng and Erwig, Martin and Walkingshaw, Eric},
  title           = {An Error-tolerant Type System for Variational Lambda
                  Calculus},
  booktitle       = {Proceedings of the 17th ACM SIGPLAN International
                  Conference on Functional Programming},
  series          = {ICFP '12},
  year            = 2012,
  isbn            = {978-1-4503-1054-3},
  location        = {Copenhagen, Denmark},
  pages           = {29--40},
  numpages        = 12,
  url             = {http://doi.acm.org/10.1145/2364527.2364535},
  doi             = {10.1145/2364527.2364535},
  acmid           = 2364535,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {error-tolerant type systems, variational lambda calculus,
                  variational type inference, variational types},
}

@article{errorSlicing,
  title           = "Type error slicing in implicitly typed higher-order
                  languages ",
  journal         = "Science of Computer Programming ",
  volume          = 50,
  number          = "1–3",
  pages           = "189 - 224",
  year            = 2004,
  note            = "12th European Symposium on Programming (ESOP 2003) ",
  issn            = "0167-6423",
  doi             = "10.1016/j.scico.2004.01.004",
  url             = "http://www.sciencedirect.com/science/article/pii/S016764230400005X",
  author          = "Christian Haack and J.B. Wells",
  keywords        = "Type error location",
  keywords        = "Type inference",
  keywords        = "Intersection types "
}

@proceedings{esop2012,
  key             = {ESOP 2012},
  booktitle       = {Proceedings of the 21st European Symposium on Programming
                  Languages and Systems (ESOP 2012)},
  title           = {Proceedings of the 21st European Symposium on Programming
                  Languages and Systems (ESOP 2012)},
  editor          = {Helmut Seidl},
  publisher       = sv,
  series          = lncs,
  volume          = 7211,
  year            = 2012,
  address         = {Tallinn, Estonia},
}

@InProceedings{exceptionalTT,
  author          = "P{\'e}drot, Pierre-Marie and Tabareau, Nicolas",
  editor          = "Ahmed, Amal",
  title           = "Failure is Not an Option",
  booktitle       = "Programming Languages and Systems",
  year            = 2018,
  publisher       = "Springer International Publishing",
  address         = "Cham",
  pages           = "245--271",
  abstract        = "We define the exceptional translation, a syntactic
                  translation of the Calculus of Inductive Constructions (CIC)
                  into itself, that covers full dependent elimination. The new
                  resulting type theory features call-by-name exceptions with
                  decidable type-checking and canonicity, but at the price of
                  inconsistency. Then, noticing parametricity amounts to
                  Kreisel's realizability in this setting, we provide an
                  additional layer on top of the exceptional translation in
                  order to tame exceptions and ensure that all exceptions used
                  locally are caught, leading to the parametric exceptional
                  translation which fully preserves consistency. This way, we
                  can consistently extend the logical expressivity of CIC with
                  independence of premises, Markov's rule, and the negation of
                  function extensionality while retaining
                  {\$}{\$}{\backslash}eta {\$}{\$}$\eta$-expansion. As a
                  byproduct, we also show that Markov's principle is not
                  provable in CIC. Both translations have been implemented in a
                  Coq plugin, which we use to formalize the examples.",
  isbn            = "978-3-319-89884-1"
}

@misc{fSTarSite,
  title           = {The {F*} Project},
  year            = 2016,
  howpublished    = {\url{http://research.microsoft.com/en-us/projects/fstar/}},
  note            = {Accessed: 2016-01-27}
},

@inproceedings{fennellThiemann:csf2013,
  author          = {Luminous Fennell and Peter Thiemann},
  title           = {Gradual Security Typing with References},
  booktitle       = {Proceedings of the 26th Computer Security Foundations
                  Symposium (CSF)},
  pages           = {224--239},
  year            = 2013,
  month           = jun,
}

@InProceedings{finiteAxiomIR,
  author          = "Dybjer, Peter and Setzer, Anton",
  editor          = "Girard, Jean-Yves",
  title           = "A Finite Axiomatization of Inductive-Recursive Definitions",
  booktitle       = "Typed Lambda Calculi and Applications",
  year            = 1999,
  publisher       = "Springer Berlin Heidelberg",
  address         = "Berlin, Heidelberg",
  pages           = "129--146",
  isbn            = "978-3-540-48959-7"
}

@article{fireTriangle,
  author          = {P\'{e}drot, Pierre-Marie and Tabareau, Nicolas},
  title           = {The Fire Triangle: How to Mix Substitution, Dependent
                  Elimination, and Effects},
  year            = 2019,
  issue_date      = {January 2020},
  publisher       = {Association for Computing Machinery},
  address         = {New York, NY, USA},
  volume          = 4,
  number          = {POPL},
  url             = {https://doi.org/10.1145/3371126},
  doi             = {10.1145/3371126},
  journal         = {Proc. ACM Program. Lang.},
  month           = dec,
  articleno       = {Article 58},
  numpages        = 28,
  keywords        = {effects, type theory}
}

@article{foetusPaper,
  author          = {Abel, Andreas and Altenkirch, Thorsten},
  title           = {A Predicative Analysis of Structural Recursion},
  journal         = {J. Funct. Program.},
  issue_date      = {January 2002},
  volume          = 12,
  number          = 1,
  month           = jan,
  year            = 2002,
  issn            = {0956-7968},
  pages           = {1--41},
  numpages        = 41,
  url             = {http://dx.doi.org/10.1017/S0956796801004191},
  doi             = {10.1017/S0956796801004191},
  acmid           = 968426,
  publisher       = {Cambridge University Press},
  address         = {New York, NY, USA},
}

@inproceedings{generalDiagnose,
  author          = {Zhang, Danfeng and Myers, Andrew C.},
  title           = {Toward General Diagnosis of Static Errors},
  booktitle       = {Proceedings of the 41st ACM SIGPLAN-SIGACT Symposium on
                  Principles of Programming Languages},
  series          = {POPL '14},
  year            = 2014,
  isbn            = {978-1-4503-2544-8},
  location        = {San Diego, California, USA},
  pages           = {569--581},
  numpages        = 13,
  url             = {http://doi.acm.org/10.1145/2535838.2535870},
  doi             = {10.1145/2535838.2535870},
  acmid           = 2535870,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {error diagnosis, information flow, static program analysis,
                  type inference},
}

@article{genrec-coin,
  title           = {{General Recursion via Coinductive Types}},
  author          = {Capretta, Venanzio},
  url             = {https://lmcs.episciences.org/2265},
  doi             = {10.2168/LMCS-1(2:1)2005},
  journal         = {Logical Methods in Computer Science},
  volume          = {Volume 1, Issue 2},
  year            = 2005,
  month           = Jul,
  keywords        = {Computer Science - Logic in Computer Science ; F.3.1}
}

@INPROCEEDINGS{gradualTypeInitial,
  author          = {Jeremy G. Siek and Walid Taha},
  title           = {Gradual Typing for Functional Languages},
  booktitle       = {Scheme and Functional Programming Workshop},
  year            = 2006,
  pages           = {81--92},
  URL = {http://scheme2006.cs.uchicago.edu/scheme2006.pdf}
}

@misc{heliumGithub,
  author          = {{Helium} Team, The},
  title           = {{Helium} Github Repository},
  year            = 2017,
  publisher       = {GitHub},
  howpublished    = {\url{https://github.com/Helium4Haskell/helium}},
}

@inproceedings{heuristicsTypeErrorDiscovery,
  author          = {Hage, Jurriaan and Heeren, Bastiaan},
  title           = {Heuristics for Type Error Discovery and Recovery},
  booktitle       = {Proceedings of the 18th International Conference on
                  Implementation and Application of Functional Languages},
  series          = {IFL'06},
  year            = 2007,
  isbn            = {978-3-540-74129-9},
  location        = {Budapest, Hungary},
  pages           = {199--216},
  numpages        = 18,
  url             = {http://dl.acm.org/citation.cfm?id=1757028.1757040},
  acmid           = 1757040,
  publisher       = {Springer-Verlag},
  address         = {Berlin, Heidelberg},
  keywords        = {constraints, error messages, error recovery, heuristics,
                  type graph, type inferencing},
}

@article{hofmann1995extensional,
  title           = {Extensional concepts in intensional type theory},
  author          = {Hofmann, Martin},
  year            = 1995,
  publisher       = {University of Edinburgh. College of Science and
                  Engineering. School of~…}
}

@Book{hottbook,
  author          = {The {Univalent Foundations Program}},
  title           = {Homotopy Type Theory: Univalent Foundations of Mathematics},
  publisher       = {\url{https://homotopytypetheory.org/book}},
  address         = {Institute for Advanced Study},
  year            = 2013
}

@article{howard1980formulae,
  title           = {The formulae-as-types notion of construction},
  author          = {Howard, William A},
  journal         = {To HB Curry: essays on combinatory logic, lambda calculus
                  and formalism},
  volume          = 44,
  pages           = {479--490},
  year            = 1980
}

@proceedings{icfp2016,
  key             = {ICFP 2016},
  booktitle       = {Proceedings of the 21st ACM SIGPLAN Conference on
                  Functional Programming (ICFP 2016)},
  title           = {Proceedings of the 21st ACM SIGPLAN Conference on
                  Functional Programming (ICFP 2016)},
  year            = 2016,
  address         = {Nara, Japan},
  month           = sep,
  publisher       = ACM,
}

@misc{icfp2017,
  key             = {ICFP 2017},
  journal         = pacmpl,
  volume          = 1,
  number          = {ICFP},
  month           = sep,
  year            = 2017,
  publisher       = acm,
}

@misc{idris2Draft,
  title           = {Idris 2: Quantitative Type Theory in Action},
  author          = {Brady, Edwin},
  journal         = {Unpublished draft},
  year            = 2020,
  howpublished    = {Unpublished draft,
                  \url{https://www.type-driven.org.uk/edwinb/papers/idris2.pdf}}
}

@misc{idrisMutRec,
  author          = { The {Idris} Community},
  title           = {Documentation for the {Idris} Language},
  year            = 2015,
  howpublished    = {\url{http://docs.idris-lang.org/en/latest/tutorial/typesfuns.html}}
}

@article{idrisPaper,
  title           = {{Idris}, a general-purpose dependently typed programming
                  language: Design and implementation},
  volume          = 23,
  DOI             = {10.1017/S095679681300018X},
  number          = 5,
  journal         = {Journal of Functional Programming},
  publisher       = {Cambridge University Press},
  author          = {Brady, Edwin},
  year            = 2013,
  pages           = {552–593}
}

@article{igarashiAl:icfp2017b,
  author          = {Igarashi, Atsushi and Thiemann, Peter and Vasconcelos,
                  Vasco T. and Wadler, Philip},
  title           = {Gradual Session Types},
  pages           = {38:1--38:28},
  crossref        = {icfp2017},
}

@inproceedings{improvedReporting,
  author          = {Yang, Jun and Michaelson, Greg and Trinder, Phil and Wells,
                  J. B.},
  title           = {Improved Type Error Reporting},
  booktitle       = {Proceedings of the 12th International Workshop on
                  Implementation of Functional Languages },
  series          = {IFL '00},
  year            = {September 2000},
  volume          = 2011,
  journal         = {Lecture Notes in Computer Science},
  pages           = {71-86},
  numpages        = 15,
  publisher       = {Springer Verlag},
  address         = {RWTH Aachen}
}


@MastersThesis{Koot:Thesis:2012,
    author     =     {Ruud Koot},
    title     =     {{Higher-Order Pattern Match Analysis}},
    school     =     {Universiteit Utrecht},
    address     =     {the Netherlands},
    year     =     {2012},
    }

@article{linearSpineCalc,
  author          = {Cervesato, Iliano and Pfenning, Frank},
  title           = {A Linear Spine Calculus},
  volume          = 13,
  number          = 5,
  pages           = {639-688},
  year            = 2003,
  doi             = {10.1093/logcom/13.5.639},
  abstract        = {We present the spine calculus S→⊸&⊤ as an efficient
                  representation for the linear $\lambda$-calculus $\lambda$→⊸&⊤ which includes
                  unrestricted functions (→) linear functions (⊸) additive
                  pairing (&) and additive unit (⊤). S→⊸&⊤ enhances the
                  representation of Church's simply typed $\lambda$-calculus by
                  enforcing extensionality and by incorporating linear
                  constructs. This approach permits procedures such as
                  unification to retain the efficient head access that
                  characterizes first-order term languages without the overhead
                  of performing η-conversions at run time. Applications lie in
                  proof search, logic programming, and logical frameworks based
                  on linear type theories. It is also related to foundational
                  work on term assignment calculi for presentations of the
                  sequent calculus. We define the spine calculus, give
                  translations of $\lambda$→⊸&⊤ into S→⊸&⊤ and vice versa, prove their
                  soundness and completeness with respect to typing and
                  reductions, and show that the typable fragment of the spine
                  calculus is strongly normalizing and admits unique canonical,
                  i.e. βη-normal, forms.},
  URL             = {http://logcom.oxfordjournals.org/content/13/5/639.abstract},
  eprint          = {http://logcom.oxfordjournals.org/content/13/5/639.full.pdf+html},
  journal         = {Journal of Logic and Computation}
}

@article{localTypeInference,
  author          = {Pierce, Benjamin C. and Turner, David N.},
  title           = {Local Type Inference},
  journal         = {ACM Trans. Program. Lang. Syst.},
  issue_date      = {Jan. 2000},
  volume          = 22,
  number          = 1,
  month           = jan,
  year            = 2000,
  issn            = {0164-0925},
  pages           = {1--44},
  numpages        = 44,
  url             = {http://doi.acm.org/10.1145/345099.345100},
  doi             = {10.1145/345099.345100},
  acmid           = 345100,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {polymorphism, subtyping, type inference},
}

@InProceedings{lowLevelDep,
  author          = "Condit, Jeremy and Harren, Matthew and Anderson, Zachary
                  and Gay, David and Necula, George C.",
  editor          = "De Nicola, Rocco",
  title           = "Dependent Types for Low-Level Programming",
  booktitle       = "Programming Languages and Systems",
  year            = 2007,
  publisher       = "Springer Berlin Heidelberg",
  address         = "Berlin, Heidelberg",
  pages           = "520--535",
  abstract        = "In this paper, we describe the key principles of a
                  dependent type system for low-level imperative languages. The
                  major contributions of this work are (1) a sound type system
                  that combines dependent types and mutation for variables and
                  for heap-allocated structures in a more flexible way than
                  before and (2) a technique for automatically inferring
                  dependent types for local variables. We have applied these
                  general principles to design Deputy, a dependent type system
                  for C that allows the user to describe bounded pointers and
                  tagged unions. Deputy has been used to annotate and check a
                  number of real-world C programs.",
  isbn            = "978-3-540-71316-6"
}

@book{martin1984intuitionistic,
  title           = {Intuitionistic type theory},
  author          = {Martin-L{\"o}f, Per and Sambin, Giovanni},
  volume          = 9,
  year            = 1984,
  publisher       = {Bibliopolis Naples}
}

@book{martin1984intuitionistic,
  title           = {Intuitionistic type theory},
  author          = {Martin-L{\"o}f, Per and Sambin, Giovanni},
  volume          = 9,
  year            = 1984,
  publisher       = {Bibliopolis Naples}
}

@article{mechanizingLF,
  title           = {Mechanizing metatheory in a logical framework},
  volume          = 17,
  DOI             = {10.1017/S0956796807006430},
  number          = {4-5},
  journal         = {Journal of Functional Programming},
  publisher       = {Cambridge University Press},
  author          = {Harper,Robert and Licata, Daniel R.},
  year            = 2007,
  pages           = {613–673}
}

@article{mgelbergpaviotti2019,
  title           = {Denotational semantics of recursive types in synthetic
                  guarded domain theory},
  volume          = 29,
  DOI             = {10.1017/S0960129518000087},
  number          = 3,
  journal         = {Mathematical Structures in Computer Science},
  publisher       = {Cambridge University Press},
  author          = {MØGELBERG, RASMUS E. and PAVIOTTI, MARCO},
  year            = 2019,
  pages           = {465–510}
}

@article{migratingGradual,
  author          = {Campora, John Peter and Chen, Sheng and Erwig, Martin and
                  Walkingshaw, Eric},
  title           = {Migrating Gradual Types},
  journal         = {Proc. ACM Program. Lang.},
  issue_date      = {January 2018},
  volume          = 2,
  number          = {POPL},
  month           = dec,
  year            = 2017,
  issn            = {2475-1421},
  pages           = {15:1--15:29},
  articleno       = 15,
  numpages        = 29,
  url             = {http://doi.acm.org/10.1145/3158103},
  doi             = {10.1145/3158103},
  acmid           = 3158103,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {gradual typing, program migration, variational types},
}


%added by bibpaste

@article{milnerAlgoW,
  title           = "A theory of type polymorphism in programming",
  journal         = "Journal of Computer and System Sciences",
  volume          = 17,
  number          = 3,
  pages           = "348 - 375",
  year            = 1978,
  issn            = "0022-0000",
  doi             = "10.1016/0022-0000(78)90014-4",
  url             = "http://www.sciencedirect.com/science/article/pii/0022000078900144",
  author          = "Robin Milner",
}
%added by bibpaste

@InProceedings{multisetOrder,
  author          = "Dershowitz, Nachum and Manna, Zohar",
  editor          = "Maurer, Hermann A.",
  title           = "Proving termination with multiset orderings",
  booktitle       = "Automata, Languages and Programming",
  year            = 1979,
  publisher       = "Springer Berlin Heidelberg",
  address         = "Berlin, Heidelberg",
  pages           = "188--202",
  abstract        = "A common tool for proving the termination of programs is
                  the well-founded set, a set ordered in such a way as to admit
                  no infinite descending sequences. The basic approach is to
                  find a termination function that maps the values of the
                  program variables into some well-founded set, such that the
                  value of the termination function is continually reduced
                  throughout the computation. All too often, the termination
                  functions required are difficult to find and are of a
                  complexity out of proportion to the program under
                  consideration. However, by providing more sophisticated
                  well-founded sets, the corresponding termination functions can
                  be simplified.",
  isbn            = "978-3-540-35168-9"
}
%added by bibpaste

@inproceedings{mumon,
  author          = {Nikhil Swamy and C\u{a}t\u{a}lin Hri\c{t}cu and Chantal
                  Keller and Aseem Rastogi and Antoine Delignat-Lavaud and Simon
                  Forest and Karthikeyan Bhargavan and C\'{e}dric Fournet and
                  Pierre-Yves Strub and Markulf Kohlweiss and Jean-Karim
                  Zinzindohou\'e and Santiago {Zanella-B\'eguelin}},
  title           = {Dependent Types and Multi-Monadic Effects in {F*}},
  booktitle       = {43rd ACM SIGPLAN-SIGACT Symposium on Principles of
                  Programming Languages (POPL)},
  shortbooktitle  = {POPL},
  pages           = {256-270},
  publisher       = {ACM},
  isbn            = {978-1-4503-3549-2},
  month           = jan,
  year            = 2016,
  ee              = {http://dx.doi.org/10.1145/2837614.2837655},
  url             = {https://www.fstar-lang.org/papers/mumon/},
}




%added by bibpaste

@inproceedings{nguyen2018sizechange,
  author          = {Nguy\~{\^e}n, Ph\'{u}c C. and Gilray, Thomas and
                  Tobin-Hochstadt, Sam and Van Horn, David},
  title           = {Size-change Termination As a Contract: Dynamically and
                  Statically Enforcing Termination for Higher-order Programs},
  booktitle       = {Proceedings of the 40th ACM SIGPLAN Conference on
                  Programming Language Design and Implementation},
  series          = {PLDI 2019},
  year            = 2019,
  isbn            = {978-1-4503-6712-7},
  location        = {Phoenix, AZ, USA},
  pages           = {845--859},
  numpages        = 15,
  url             = {http://doi.acm.org/10.1145/3314221.3314643},
  doi             = {10.1145/3314221.3314643},
  acmid           = 3314643,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {size-change principle, termination, verification},
}
%added by bibpaste

@misc{ourGH,
  author          = {Eremondi, Joseph},
  title           = {Github Repository: lambda-pi-constraint, tag thesis-final},
  year            = 2016,
  publisher       = {GitHub},
  journal         = {GitHub repository},
  howpublished    = {\url{https://github.com/JoeyEremondi/lambda-pi-constraint}},
}

%added by bibload

@misc{parametricityRevisited,
  title           = {Gradual Parametricity, Revisited},
  author          = {Mat{\i}as Toro and Elizabeth Labrada and Éric Tanter},
  year            = 2018,
  eprint          = {1807.04596},
  archivePrefix   = {arXiv},
  primaryClass    = {cs.PL}
}


%added by bibload

@incollection{paulinmohring:hal-01094195,
  TITLE           = {{Introduction to the Calculus of Inductive Constructions}},
  AUTHOR          = {Paulin-Mohring, Christine},
  URL             = {https://hal.inria.fr/hal-01094195},
  BOOKTITLE       = {{All about Proofs, Proofs for All}},
  EDITOR          = {Bruno Woltzenlogel Paleo and David Delahaye},
  PUBLISHER       = {{College Publications}},
  SERIES          = {Studies in Logic (Mathematical logic and foundations)},
  VOLUME          = 55,
  YEAR            = 2015,
  MONTH           = Jan,
  KEYWORDS        = {Coq proof assistant ; Calculus of Inductive Constructions},
  PDF             = {https://hal.inria.fr/hal-01094195/file/CIC.pdf},
  HAL_ID          = {hal-01094195},
  HAL_VERSION     = {v1},
}
%added by bibpaste

@proceedings{popl2017,
  key             = {POPL 2017},
  booktitle       = {Proceedings of the 44th {ACM SIGPLAN-SIGACT} Symposium on
                  Principles of Programming Languages (POPL 2017)},
  title           = {Proceedings of the 44th {ACM SIGPLAN-SIGACT} Symposium on
                  Principles of Programming Languages (POPL 2017)},
  year            = 2017,
  address         = {Paris, France},
  month           = jan,
  publisher       = acm,
}




%added by bibpaste

@article{predSysF,
  author          = {Cyprien Mangin and Matthieu Sozeau},
  title           = {Equations for Hereditary Substitution in Leivant's
                  Predicative System {F:} {A} Case Study},
  journal         = {CoRR},
  volume          = {abs/1508.00455},
  year            = 2015,
  url             = {http://arxiv.org/abs/1508.00455},
  archivePrefix   = {arXiv},
  eprint          = {1508.00455},
  timestamp       = {Mon, 13 Aug 2018 16:48:30 +0200},
  biburl          = {https://dblp.org/rec/bib/journals/corr/ManginS15},
  bibsource       = {dblp computer science bibliography, https://dblp.org}
}

@InProceedings{productive,
  title           = {Productive Coprogramming with Guarded Recursion},
  author          = {Robert Atkey and Conor McBride},
  year            = 2013,
  doi             = {10.1145/2500365.2500597},
  booktitle       = {18th ACM SIGPLAN International Conference on Functional
                  Programming (ICFP 2013)}
}
%added by bibpaste

@misc{reddit-agda,
  title           = {/r/agda: R x → x == y → R y},
  year            = 2016,
  howpublished    = {\url{https://www.reddit.com/r/agda/comments/7lq44q/r_x_x_y_r_y/}},
  note            = {Accessed: 2018-06-14},
  author          = {/u/GNULinuxProgrammer}
}

@InProceedings{refinedCriteria,
  author          = {Jeremy G. Siek and Michael M. Vitousek and Matteo Cimini
                  and John Tang Boyland},
  title           = {{Refined Criteria for Gradual Typing}},
  booktitle       = {1st Summit on Advances in Programming Languages (SNAPL
                  2015)},
  pages           = {274--293},
  series          = {Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN            = {978-3-939897-80-4},
  ISSN            = {1868-8969},
  year            = 2015,
  volume          = 32,
  editor          = {Thomas Ball and Rastislav Bodik and Shriram Krishnamurthi
                  and Benjamin S. Lerner and Greg Morrisett},
  publisher       = {Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
  address         = {Dagstuhl, Germany},
  URL             = {http://drops.dagstuhl.de/opus/volltexte/2015/5031},
  URN             = {urn:nbn:de:0030-drops-50312},
  doi             = {10.4230/LIPIcs.SNAPL.2015.274},
  annote          = {Keywords: gradual typing, type systems, semantics, dynamic
                  languages}
}

%added by bibpaste

@InProceedings{ringer_et_al:LIPIcs:2019:11081,
  author          = {Talia Ringer and Nathaniel Yazdani and John Leo and Dan
                  Grossman},
  title           = {{Ornaments for Proof Reuse in Coq}},
  booktitle       = {10th International Conference on Interactive Theorem
                  Proving (ITP 2019)},
  pages           = {26:1--26:19},
  series          = {Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN            = {978-3-95977-122-1},
  ISSN            = {1868-8969},
  year            = 2019,
  volume          = 141,
  editor          = {John Harrison and John O'Leary and Andrew Tolmach},
  publisher       = {Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
  address         = {Dagstuhl, Germany},
  URL             = {http://drops.dagstuhl.de/opus/volltexte/2019/11081},
  URN             = {urn:nbn:de:0030-drops-110816},
  doi             = {10.4230/LIPIcs.ITP.2019.26},
  annote          = {Keywords: ornaments, proof reuse, proof automation}
}

%added by bibload

@article{rosser_1936,
  title           = {Extensions of some theorems of Gödel and Church},
  volume          = 1,
  DOI             = {10.2307/2269028},
  number          = 3,
  journal         = {Journal of Symbolic Logic},
  publisher       = {Cambridge University Press},
  author          = {Rosser, Barkley},
  year            = 1936,
  pages           = {87–91}
}

%added by bibload

@misc{sbe,
  author          = {Diehl, Larry and Sheard, Tim},
  title           = {Hereditary Substitutionby Canonical Evaluation (SbE)},
  year            = 2014,
  howpublished    = {Unpublished draft,
                  \url{http://www.larrytheliquid.com/drafts/sbe.pdf}}
}
%added by bibpaste

@inproceedings{sergeyClarke:esop2012,
  author          = {Ilya Sergey and Dave Clarke},
  title           = {Gradual Ownership Types},
  crossref        = {esop2012},
  pages           = {579--599},
}
%added by bibpaste

@Inbook{setConstraintPearl,
  author          = "Pacholski, Leszek and Podelski, Andreas",
  editor          = "Smolka, Gert",
  title           = "Set constraints: A pearl in research on constraints",
  bookTitle       = "Principles and Practice of Constraint Programming-CP97:
                  Third International Conference, CP97 Linz, Austria, October 29
                  -- November 1, 1997 Proceedings",
  year            = 1997,
  publisher       = "Springer Berlin Heidelberg",
  address         = "Berlin, Heidelberg",
  pages           = "549--561",
  abstract        = "The topic of set constraints is a pearl among the research
                  topics on constraints. It combines theoretical investigations
                  (ranging from logical expressiveness, decidability, algorithms
                  and complexity analysis to program semantics and domain
                  theory) with practical experiments in building systems for
                  program analysis, addressing questions like implementation
                  issues and scalability. The research has its direct
                  applications in type inference, optimization and verification
                  of imperative, functional, logic and reactive programs.",
  isbn            = "978-3-540-69642-1",
  doi             = "10.1007/BFb0017466",
  url             = "https://doi.org/10.1007/BFb0017466"
}

@article{setConstraintsProjection,
  author          = {Pacholski, Witold Charatonik Leszek},
  title           = {Set Constraints with Projections},
  journal         = {J. ACM},
  issue_date      = {April 2010},
  volume          = 57,
  number          = 4,
  month           = may,
  year            = 2010,
  issn            = {0004-5411},
  pages           = {23:1--23:37},
  articleno       = 23,
  numpages        = 37,
  url             = {http://doi.acm.org/10.1145/1734213.1734217},
  doi             = {10.1145/1734213.1734217},
  acmid           = 1734217,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {Computational complexity, program analysis, set
                  constraints},
}

@article{sherrlocHolistic,
  author          = {Zhang, Danfeng and Myers, Andrew C. and Vytiniotis,
                  Dimitrios and Peyton-Jones, Simon},
  title           = {SHErrLoc: A Static Holistic Error Locator},
  journal         = {ACM Trans. Program. Lang. Syst.},
  issue_date      = {September 2017},
  volume          = 39,
  number          = 4,
  month           = aug,
  year            = 2017,
  issn            = {0164-0925},
  pages           = {18:1--18:47},
  articleno       = 18,
  numpages        = 47,
  url             = {http://doi.acm.org/10.1145/3121137},
  doi             = {10.1145/3121137},
  acmid           = 3121137,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {Error diagnosis, Haskell, Jif, OCaml, information flow,
                  static program analysis, type inference},
}

@inproceedings{sherrlocPaper,
  author          = {Zhang, Danfeng and Myers, Andrew C. and Vytiniotis,
                  Dimitrios and Peyton-Jones, Simon},
  title           = {Diagnosing Type Errors with Class},
  booktitle       = {Proceedings of the 36th ACM SIGPLAN Conference on
                  Programming Language Design and Implementation},
  series          = {PLDI 2015},
  year            = 2015,
  isbn            = {978-1-4503-3468-6},
  location        = {Portland, OR, USA},
  pages           = {12--21},
  numpages        = 10,
  url             = {http://doi.acm.org/10.1145/2737924.2738009},
  doi             = {10.1145/2737924.2738009},
  acmid           = 2738009,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {Error diagnosis, Haskell, type inference},
}

@inproceedings{siekVachharajani:dls2008,
  author          = {Siek, Jeremy G. and Manish Vachharajani},
  title           = {Gradual typing with unification-based inference},
  crossref        = {dls2008},
}

%% lmcs:2265
%% https://lmcs.episciences.org/2265
%%

@article{solvingStrategies,
  author          = {Hage, Jurriaan and Heeren, Bastiaan},
  title           = {Strategies for Solving Constraints in Type and Effect
                  Systems},
  journal         = {Electron. Notes Theor. Comput. Sci.},
  issue_date      = {April, 2009},
  volume          = 236,
  month           = apr,
  year            = 2009,
  issn            = {1571-0661},
  pages           = {163--183},
  numpages        = 21,
  url             = {http://dx.doi.org/10.1016/j.entcs.2009.03.021},
  doi             = {10.1016/j.entcs.2009.03.021},
  acmid           = 1519622,
  publisher       = {Elsevier Science Publishers B. V.},
  address         = {Amsterdam, The Netherlands, The Netherlands},
  keywords        = {constraints, inference algorithms, solving strategies, type
                  and effect systems}
}


@article{stump_2017,
  title           = {The calculus of dependent lambda eliminations},
  volume          = 27,
  DOI             = {10.1017/S0956796817000053},
  journal         = {Journal of Functional Programming},
  publisher       = {Cambridge University Press},
  author          = {Stump, Aaron},
  year            = 2017,
  pages           = {e14}
}

@INPROCEEDINGS{systemsNeg,
  author          = {K. Stefansson},
  booktitle       = {Proceedings Ninth Annual IEEE Symposium on Logic in
                  Computer Science},
  title           = {Systems of set constraints with negative constraints are
                  NEXPTIME-complete},
  year            = 1994,
  pages           = {137-141},
  keywords        = {computational complexity;decidability;formal logic;set
                  theory;Diophantine
                  problem;NEXPTIME-complete;NP-complete;complexity;decidable;ground
                  terms;negative constraints;nonlinear reachability
                  problem;ranked alphabet;set constraints;Artificial
                  intelligence;Automata;Computer science;Cost
                  accounting;Polynomials;Tellurium},
  doi             = {10.1109/LICS.1994.316077},
  month           = {Jul},
}

@Misc{tata2007,
  author          = {H. Comon and M. Dauchet and R. Gilleron and C. L\"oding and
                  F. Jacquemard and D. Lugiez and S. Tison and M. Tommasi},
  title           = {Tree Automata Techniques and Applications},
  howpublished    = {Available on: \url{http://www.grappa.univ-lille3.fr/tata}},
  note            = {release October, 12th 2007},
  year            = 2007
}

@online{thesisProposalContract,
  author          = {Matthew Might},
  title           = {A Ph.D. thesis proposal is a contract},
  year            = 2010,
  url             = {http://matt.might.net/articles/advice-for-phd-thesis-proposals/},
  urldate         = {2019-10-01}
}

@inproceedings{toro2017gradual,
  title           = {A gradual interpretation of union types},
  author          = {Toro, Mat{\'\i}as and Tanter, {\'E}ric},
  booktitle       = {International Static Analysis Symposium},
  pages           = {382--404},
  year            = 2017,
  organization    = {Springer}
}

@article{toroAl:toplas2018,
  author          = {Mat{\'i}as Toro and Ronald Garcia and {\'E}ric Tanter},
  title           = {Type-Driven Gradual Security with References},
  journal         = toplas,
  publisher       = acm,
  pages           = {16:1--16:55},
  volume          = 40,
  number          = 4,
  year            = 2018,
  month           = nov,
  users           = { etanter , mtoro },
  urlpdf          = {http://pleiad.dcc.uchile.cl/papers/2018/toroAl-toplas2018.pdf},
  urldoi          = {https://doi.org/10.1145/3229061},
  webnote         = {Presented at POPL 2019},
}

@INPROCEEDINGS{treeAutomataSetNeg,
  author          = {R. Gilleron and S. Tison and M. Tommasi},
  booktitle       = {Proceedings of 1993 IEEE 34th Annual Foundations of
                  Computer Science},
  title           = {Solving systems of set constraints with negated subset
                  relationships},
  year            = 1993,
  pages           = {372-380},
  keywords        = {automata theory;constraint handling;decidability;formal
                  languages;decision procedure;negated subset
                  relationships;regular tree languages;satisfiability;systems of
                  set constraints;tree automata techniques;Algebra;Algorithm
                  design and analysis;Automata;Constraint theory;Inference
                  algorithms;Logic programming},
  doi             = {10.1109/SFCS.1993.366850},
  month           = {Nov},
}

@misc{typeErrorMessages,
  Author          = {Serrano, Alejandro and Hage, Juriaan and Heeren, Bastiaan},
  Institution     = {Universiteit Utrecht},
  Howpublished    = {\url{http://www.cs.uu.nl/docs/vakken/apa/09alejandroslides.pdf}},
  Year            = {June 10, 2014},
  Title           = {{(Type)} Error Diagnosis}
}

@InProceedings{undecideInference,
  author          = "Dowek, Gilles",
  editor          = "Bezem, Marc and Groote, Jan Friso",
  title           = "The undecidability of typability in the Lambda-Pi-calculus",
  booktitle       = "Typed Lambda Calculi and Applications",
  year            = 1993,
  publisher       = "Springer Berlin Heidelberg",
  address         = "Berlin, Heidelberg",
  pages           = "139--145",
  abstract        = "The set of pure terms which are typable in the
                  $\lambda$II-calculus in a given context is not recursive. So
                  there is no general type inference algorithm for the
                  programming language Elf and, in some cases, some type
                  information has to be mentioned by the programmer.",
  isbn            = "978-3-540-47586-6"
}

@article{uniCoq,
  title           = {A comprehensible guide to a new unifier for {CIC} including
                  universe polymorphism and overloading},
  volume          = 27,
  DOI             = {10.1017/S0956796817000028},
  journal         = {Journal of Functional Programming},
  publisher       = {Cambridge University Press},
  author          = {Ziliani, Beta and Sozeau, Matthieu},
  year            = 2017,
  pages           = {e10}
}

@incollection{unifSigma,
  year            = 2011,
  isbn            = {978-3-642-21690-9},
  booktitle       = {Typed Lambda Calculi and Applications},
  volume          = 6690,
  series          = {Lecture Notes in Computer Science},
  editor          = {Ong, Luke},
  doi             = {10.1007/978-3-642-21691-6_5},
  title           = {Higher-Order Dynamic Pattern Unification for Dependent
                  Types and Records},
  url             = {http://dx.doi.org/10.1007/978-3-642-21691-6_5},
  publisher       = {Springer Berlin Heidelberg},
  author          = {Abel, Andreas and Pientka, Brigitte},
  pages           = {10-26},
  language        = {English}
}

@misc{unifTutorial,
  title           = {A tutorial implementation of dynamic pattern unification},
  author          = {Gundry, Adam and McBride, Conor},
  journal         = {Unpublished draft},
  year            = 2013,
  howpublished    = {Unpublished draft,
                  \url{http://adam.gundry.co.uk/pub/pattern-unify/pattern-unification-2012-07-10.pdf}}
}

@article{varInference,
  author          = {Chen, Sheng and Erwig, Martin and Walkingshaw, Eric},
  title           = {Extending Type Inference to Variational Programs},
  journal         = {ACM Trans. Program. Lang. Syst.},
  issue_date      = {March 2014},
  volume          = 36,
  number          = 1,
  month           = mar,
  year            = 2014,
  issn            = {0164-0925},
  pages           = {1:1--1:54},
  articleno       = 1,
  numpages        = 54,
  url             = {http://doi.acm.org/10.1145/2518190},
  doi             = {10.1145/2518190},
  acmid           = 2518190,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {Variational lambda calculus, variational type inference,
                  variational types},
}

@inproceedings{withoutK,
  author          = {Cockx, Jesper and Devriese, Dominique and Piessens, Frank},
  title           = {Pattern Matching Without K},
  booktitle       = {Proceedings of the 19th ACM SIGPLAN International
                  Conference on Functional Programming},
  series          = {ICFP '14},
  year            = 2014,
  isbn            = {978-1-4503-2873-9},
  location        = {Gothenburg, Sweden},
  pages           = {257--268},
  numpages        = 12,
  url             = {http://doi.acm.org/10.1145/2628136.2628139},
  doi             = {10.1145/2628136.2628139},
  acmid           = 2628139,
  publisher       = {ACM},
  address         = {New York, NY, USA},
  keywords        = {agda, dependent pattern matching, homotopy type theory, k
                  axiom},
}


@conference{c4be73a0daf74c9aa4d13483a2c4dd0e,
title = "$\lambda$dB: Blame tracking at higher fidelity",
abstract = "This paper introduces $\lambda$dB, a blame calculus with dependent types. It supports dependent functions, predicate refinement at all types, the dynamic type, and full blame tracking. It is inspired by and extends previous work on hybrid types and Sage, by Flanagan and others; manifest contracts, by Greenberg, Pierce, and Weirich; and blame calculus by Wadler and Findler. While previous work only allows refinement over base types, $\lambda$dB supports refinement over any type. We introduce novel techniques in order to prove blame safety for this language, including a careful analysis that reduces open judgments on terms to closed ones on values, and the idea of {\textquoteleft}subtyping with a witness{\textquoteright}, which fix flaws in the previous work of Wadler and Findler. These technical contributions mean that we can achieve a completely operational account of the metatheory of our language, and thereby avoid the need to intertwine operational and semantic models which bedevils the work on hybrid types and manifest contracts.",
author = "Jakub Zalewski and James McKinna and Morris, {J. Garrett} and Philip Wadler",
year = "2020",
language = "English",
note = "First ACM SIGPLAN Workshop on Gradual Typing 2020, WGT 2020 ; Conference date: 19-01-2020 Through 25-01-2020",
URL = {https://wgt20.irif.fr/wgt20-final98-acmpaginated.pdf}

}


@InProceedings{lean,
author="de Moura, Leonardo
and Kong, Soonho
and Avigad, Jeremy
and van Doorn, Floris
and von Raumer, Jakob",
editor="Felty, Amy P.
and Middeldorp, Aart",
title="The Lean Theorem Prover (System Description)",
booktitle="Automated Deduction - CADE-25",
year="2015",
publisher="Springer International Publishing",
address="Cham",
pages="378--388",
abstract="Lean is a new open source theorem prover being developed at Microsoft Research and Carnegie Mellon University, with a small trusted kernel based on dependent type theory. It aims to bridge the gap between interactive and automated theorem proving, by situating automated tools and methods in a framework that supports user interaction and the construction of fully specified axiomatic proofs. Lean is an ongoing and long-term effort, but it already provides many useful components, integrated development environments, and a rich API which can be used to embed it into other systems. It is currently being used to formalize category theory, homotopy type theory, and abstract algebra. We describe the project goals, system architecture, and main features, and we discuss applications and continuing work.",
isbn="978-3-319-21401-6"
}

@article{DBLP:journals/corr/abs-2104-00480,
  author    = {Edwin C. Brady},
  title     = {Idris 2: Quantitative Type Theory in Practice},
  journal   = {CoRR},
  volume    = {abs/2104.00480},
  year      = {2021},
  url       = {https://arxiv.org/abs/2104.00480},
  archivePrefix = {arXiv},
  eprint    = {2104.00480},
  timestamp = {Mon, 12 Apr 2021 16:14:56 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/abs-2104-00480.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@phdthesis{dtfpp,
  author    = {Conor McBride},
  title     = {Dependently typed functional programs and their proofs},
  school    = {University of Edinburgh, {UK}},
  year      = {2000},
  url       = {http://hdl.handle.net/1842/374},
  timestamp = {Mon, 26 Sep 2016 17:14:49 +0200},
  biburl    = {https://dblp.org/rec/phd/ethos/McBride00.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@InProceedings{LennonBertrand2021,
  author    = {Lennon-Bertrand, Meven},
  booktitle = {12th International Conference on Interactive Theorem Proving (ITP 2021)},
  title     = {{Complete Bidirectional Typing for the Calculus of Inductive Constructions}},
  doi       = {10.4230/LIPIcs.ITP.2021.24},
  editor    = {Cohen, Liron and Kaliszyk, Cezary},
  isbn      = {978-3-95977-188-7},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  series    = {Leibniz International Proceedings in Informatics (LIPIcs)},
  url       = {https://drops.dagstuhl.de/opus/volltexte/2021/13919},
  volume    = {193},
  annote    = {Keywords: Bidirectional Typing, Calculus of Inductive Constructions, Coq, Proof Assistants},
  file      = {:LennonBertrand2021 - Complete Bidirectional Typing for the Calculus of Inductive Constructions.pdf:PDF},
  issn      = {1868-8969},
  urn       = {urn:nbn:de:0030-drops-139194},
  year      = {2021},
}
@book{tdd-book,
  title={Type-driven development with Idris},
  author={Brady, Edwin},
  year={2017},
  publisher={Manning},
  isbn = {9781617293023},
  url = {https://www.manning.com/books/type-driven-development-with-idris}
}

@article{10.1145/3434342,
author = {Ba\~{n}ados Schwerter, Felipe and Clark, Alison M. and Jafery, Khurram A. and Garcia, Ronald},
title = {Abstracting Gradual Typing Moving Forward: Precise and Space-Efficient},
year = {2021},
issue_date = {January 2021},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {5},
number = {POPL},
url = {https://doi.org/10.1145/3434342},
doi = {10.1145/3434342},
abstract = {Abstracting Gradual Typing (AGT) is a systematic approach to designing gradually-typed
languages. Languages developed using AGT automatically satisfy the formal semantic
criteria for gradual languages identified by Siek et al. Nonetheless, vanilla AGT
semantics can still have important shortcomings. First, a gradual language's runtime
checks should preserve the space-efficiency guarantees inherent to the underlying
static and dynamic languages. To the contrary, the default operational semantics of
AGT break proper tail calls. Second, a gradual language's runtime checks should enforce
basic modular type-based invariants expected from the static type discipline. To the
contrary, the default operational semantics of AGT may fail to enforce some invariants
in surprising ways. We demonstrate this in the GTFL≲ language of Garcia et al.  This
paper addresses both problems at once by refining the theory underlying AGT's dynamic
checks. Garcia et al. observe that AGT involves two abstractions of static types:
one for the static semantics and one for the dynamic semantics. We recast the latter
as an abstract interpretation of subtyping itself, while gradual types still abstract
static types. Then we show how forward-completeness (Giacobazzi and Quintarelli) is
key to supporting both space-efficient execution and reliable runtime type enforcement.},
journal = {Proc. ACM Program. Lang.},
month = jan,
articleno = {61},
numpages = {28},
keywords = {abstract interpretation, gradual typing, cast calculi, subtyping}
}

@article{10.1145/3434288,
author = {Jacobs, Koen and Timany, Amin and Devriese, Dominique},
title = {Fully Abstract from Static to Gradual},
year = {2021},
issue_date = {January 2021},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {5},
number = {POPL},
url = {https://doi.org/10.1145/3434288},
doi = {10.1145/3434288},
abstract = {What is a good gradual language? Siek et al. have previously proposed the refined
criteria, a set of formal ideas that characterize a range of guarantees typically
expected from a gradual language. While these go a long way, they are mostly focused
on syntactic and type safety properties and fail to characterize how richer semantic
properties and reasoning principles that hold in the static language, like non-interference
or parametricity for instance, should be upheld in the gradualization. In this paper,
we investigate and argue for a new criterion previously hinted at by Devriese et al.:
the embedding from the static to the gradual language should be fully abstract. Rather
than preserving an arbitrarily chosen interpretation of source language types, this
criterion requires that all source language equivalences are preserved. We demonstrate
that the criterion weeds out erroneous gradualizations that nevertheless satisfy the
refined criteria. At the same time, we demonstrate that the criterion is realistic
by reporting on a mechanized proof that the property holds for a standard example:
GTLCµ, the natural gradualization of STLCµ, the simply typed lambda-calculus with
equirecursive types. We argue thus that the criterion is useful for understanding,
evaluating, and guiding the design of gradual languages, particularly those which
are intended to preserve source language guarantees in a rich way.},
journal = {Proc. ACM Program. Lang.},
month = jan,
articleno = {7},
numpages = {30},
keywords = {fully abstract embedding, fully abstract compilation, gradual typing}
}
@inproceedings{bird1998nested,
author = {Bird, Richard S. and Meertens, Lambert G. L. T.},
title = {Nested Datatypes},
year = {1998},
isbn = {3540645918},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
booktitle = {Proceedings of the Mathematics of Program Construction},
pages = {52–67},
numpages = {16},
series = {MPC '98}
}

@incollection{MARTINLOF1982153,
title = {Constructive Mathematics and Computer Programming},
editor = {L. Jonathan Cohen and Jerzy Łoś and Helmut Pfeiffer and Klaus-Peter Podewski},
series = {Studies in Logic and the Foundations of Mathematics},
publisher = {Elsevier},
volume = {104},
pages = {153-175},
year = {1982},
booktitle = {Logic, Methodology and Philosophy of Science VI},
issn = {0049-237X},
doi = {https://doi.org/10.1016/S0049-237X(09)70189-2},
url = {https://www.sciencedirect.com/science/article/pii/S0049237X09701892},
author = {Per Martin-Löf},
abstract = {Publisher Summary
This chapter discusses that relating constructive mathematics to computer programming seems to be beneficial. Among the benefits to be derived by constructive mathematics from its association with computer programming, one is that you see immediately why you cannot rely upon the law of excluded middle: its uninhibited use would lead to programs that one did not know how to execute. By choosing to program in a formal language for constructive mathematics, like the theory of types, one gets access to the conceptual apparatus of pure mathematics, neglecting those parts that depend critically on the law of excluded middle, whereas even the best high level programming languages so far designed are wholly inadequate as mathematical languages. The virtue of a machine code is that a program written in it can be directly read and executed by the machine. The distinction between low and high level programming languages is of course relative to the available hardware. It may well be possible to turn what is now regarded as a high level programming language into machine code by the invention of new hardware.}
}

@InProceedings{McBride2002,
  author    = {McBride, Conor},
  booktitle = {Types for {Proofs} and {Programs}},
  date      = {2002},
  year      = {2002},
  title     = {Elimination with a {Motive}},
  doi       = {10.1007/3-540-45842-5_13},
  editor    = {Callaghan, Paul and Luo, Zhaohui and McKinna, James and Pollack, Robert and Pollack, Robert},
  isbn      = {9783540458425},
  language  = {en},
  location  = {Berlin, Heidelberg},
  pages     = {197--216},
  publisher = {Springer},
  series    = {Lecture {Notes} in {Computer} {Science}},
  abstract  = {Elimination rules tell us how we may exploit hypotheses in the course of a proof. Many common elimination rules, such as ∨-elim and the induction principles for inductively defined datatypes and relations, are parametric in their conclusion. We typically instantiate this parameter with the goal we are trying to prove, and acquire subproblems specialising this goal to particular circumstances in which the eliminated hypothesis holds. This paper describes a generic tactic, Elim, which supports this ubiquitous idiom in interactive proof and subsumes the functionality of the more specific ‘induction’ and ‘inversion’ tactics found in systems like Coq and Lego[6][7][15]. Elim also supports user-derived rules which follow the same style.},
  file      = {:misc/McBride2002 - Elimination with a Motive.html:URL},
  keywords  = {Type Theory , Dependency Graph , Recursive Call , Dependent Type , Elimination Rule },
}


@article{10.1145/3093333.3009882,
author = {Dolan, Stephen and Mycroft, Alan},
title = {Polymorphism, Subtyping, and Type Inference in MLsub},
year = {2017},
issue_date = {January 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {52},
number = {1},
issn = {0362-1340},
url = {https://doi.org/10.1145/3093333.3009882},
doi = {10.1145/3093333.3009882},
abstract = { We present a type system combining subtyping and ML-style parametric polymorphism. Unlike previous work, our system supports type inference and has compact principal types. We demonstrate this system in the minimal language MLsub, which types a strict superset of core ML programs.  This is made possible by keeping a strict separation between the types used to describe inputs and those used to describe outputs, and extending the classical unification algorithm to handle subtyping constraints between these input and output types. Principal types are kept compact by type simplification, which exploits deep connections between subtyping and the algebra of regular languages. An implementation is available online. },
journal = {SIGPLAN Not.},
month = {jan},
pages = {60–72},
numpages = {13},
keywords = {Type Inference, Subtyping, Polymorphism, Algebra}
}



@inproceedings{10.1145/3009837.3009882,
author = {Dolan, Stephen and Mycroft, Alan},
title = {Polymorphism, Subtyping, and Type Inference in MLsub},
year = {2017},
isbn = {9781450346603},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3009837.3009882},
doi = {10.1145/3009837.3009882},
abstract = { We present a type system combining subtyping and ML-style parametric polymorphism. Unlike previous work, our system supports type inference and has compact principal types. We demonstrate this system in the minimal language MLsub, which types a strict superset of core ML programs.  This is made possible by keeping a strict separation between the types used to describe inputs and those used to describe outputs, and extending the classical unification algorithm to handle subtyping constraints between these input and output types. Principal types are kept compact by type simplification, which exploits deep connections between subtyping and the algebra of regular languages. An implementation is available online. },
booktitle = {Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages},
pages = {60–72},
numpages = {13},
keywords = {Polymorphism, Type Inference, Algebra, Subtyping},
location = {Paris, France},
series = {POPL 2017}
}
@inproceedings{10.1145/2500365.2500603,
author = {Garcia, Ronald},
title = {Calculating Threesomes, with Blame},
year = {2013},
isbn = {9781450323260},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2500365.2500603},
doi = {10.1145/2500365.2500603},
abstract = {Coercions and threesomes both enable a language to combine static and dynamic types while avoiding cast-based space leaks. Coercion calculi elegantly specify space-efficient cast behavior, even when augmented with blame tracking, but implementing their semantics directly is difficult. Threesomes, on the other hand, have a straightforward recursive implementation, but endowing them with blame tracking is challenging. In this paper, we show that you can use that elegant spec to produce that straightforward implementation: we use the coercion calculus to derive threesomes with blame. In particular, we construct novel threesome calculi for blame tracking strategies that detect errors earlier, catch more errors, and reflect an intuitive conception of safe and unsafe casts based on traditional subtyping.},
booktitle = {Proceedings of the 18th ACM SIGPLAN International Conference on Functional Programming},
pages = {417–428},
numpages = {12},
keywords = {labeled types, coercions, casts, space efficiency, threesomes},
location = {Boston, Massachusetts, USA},
series = {ICFP '13}
}



@article{10.1145/2544174.2500603,
author = {Garcia, Ronald},
title = {Calculating Threesomes, with Blame},
year = {2013},
issue_date = {September 2013},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {48},
number = {9},
issn = {0362-1340},
url = {https://doi.org/10.1145/2544174.2500603},
doi = {10.1145/2544174.2500603},
abstract = {Coercions and threesomes both enable a language to combine static and dynamic types while avoiding cast-based space leaks. Coercion calculi elegantly specify space-efficient cast behavior, even when augmented with blame tracking, but implementing their semantics directly is difficult. Threesomes, on the other hand, have a straightforward recursive implementation, but endowing them with blame tracking is challenging. In this paper, we show that you can use that elegant spec to produce that straightforward implementation: we use the coercion calculus to derive threesomes with blame. In particular, we construct novel threesome calculi for blame tracking strategies that detect errors earlier, catch more errors, and reflect an intuitive conception of safe and unsafe casts based on traditional subtyping.},
journal = {SIGPLAN Not.},
month = {sep},
pages = {417–428},
numpages = {12},
keywords = {coercions, labeled types, casts, threesomes, space efficiency}
}
@inproceedings{10.1145/2737924.2737968,
author = {Siek, Jeremy and Thiemann, Peter and Wadler, Philip},
title = {Blame and Coercion: Together Again for the First Time},
year = {2015},
isbn = {9781450334686},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2737924.2737968},
doi = {10.1145/2737924.2737968},
abstract = { C#, Dart, Pyret, Racket, TypeScript, VB: many recent languages integrate dynamic and static types via gradual typing. We systematically develop three calculi for gradual typing and the relations between them, building on and strengthening previous work. The calculi are: $\lambda$B, based on the blame calculus of Wadler and Findler (2009); $\lambda$C, inspired by the coercion calculus of Henglein (1994); $\lambda$S inspired by the space-efficient calculus of Herman, Tomb, and Flanagan (2006) and the threesome calculus of Siek and Wadler (2010). While $\lambda$B is little changed from previous work, $\lambda$C and $\lambda$S are new. Together, $\lambda$B, $\lambda$C, and $\lambda$S provide a coherent foundation for design, implementation, and optimisation of gradual types. We define translations from $\lambda$B to $\lambda$C and from $\lambda$C to $\lambda$S. Much previous work lacked proofs of correctness or had weak correctness criteria; here we demonstrate the strongest correctness criterion one could hope for, that each of the translations is fully abstract. Each of the calculi reinforces the design of the others: $\lambda$C has a particularly simple definition, and the subtle definition of blame safety for $\lambda$B is justified by the simple definition of blame safety for $\lambda$C. Our calculus $\lambda$S is implementation-ready: the first space-efficient calculus that is both straightforward to implement and easy to understand. We give two applications: first, using full abstraction from $\lambda$C to $\lambda$S to validate the challenging part of full abstraction between $\lambda$B and $\lambda$C; and, second, using full abstraction from $\lambda$B to $\lambda$S to easily establish the Fundamental Property of Casts, which required a custom bisimulation and six lemmas in earlier work. },
booktitle = {Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {425–435},
numpages = {11},
keywords = {gradual typing, Blame, lambda calculus},
location = {Portland, OR, USA},
series = {PLDI '15}
}



@article{10.1145/2813885.2737968,
author = {Siek, Jeremy and Thiemann, Peter and Wadler, Philip},
title = {Blame and Coercion: Together Again for the First Time},
year = {2015},
issue_date = {June 2015},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {50},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/2813885.2737968},
doi = {10.1145/2813885.2737968},
abstract = { C#, Dart, Pyret, Racket, TypeScript, VB: many recent languages integrate dynamic and static types via gradual typing. We systematically develop three calculi for gradual typing and the relations between them, building on and strengthening previous work. The calculi are: $\lambda$B, based on the blame calculus of Wadler and Findler (2009); $\lambda$C, inspired by the coercion calculus of Henglein (1994); $\lambda$S inspired by the space-efficient calculus of Herman, Tomb, and Flanagan (2006) and the threesome calculus of Siek and Wadler (2010). While $\lambda$B is little changed from previous work, $\lambda$C and $\lambda$S are new. Together, $\lambda$B, $\lambda$C, and $\lambda$S provide a coherent foundation for design, implementation, and optimisation of gradual types. We define translations from $\lambda$B to $\lambda$C and from $\lambda$C to $\lambda$S. Much previous work lacked proofs of correctness or had weak correctness criteria; here we demonstrate the strongest correctness criterion one could hope for, that each of the translations is fully abstract. Each of the calculi reinforces the design of the others: $\lambda$C has a particularly simple definition, and the subtle definition of blame safety for $\lambda$B is justified by the simple definition of blame safety for $\lambda$C. Our calculus $\lambda$S is implementation-ready: the first space-efficient calculus that is both straightforward to implement and easy to understand. We give two applications: first, using full abstraction from $\lambda$C to $\lambda$S to validate the challenging part of full abstraction between $\lambda$B and $\lambda$C; and, second, using full abstraction from $\lambda$B to $\lambda$S to easily establish the Fundamental Property of Casts, which required a custom bisimulation and six lemmas in earlier work. },
journal = {SIGPLAN Not.},
month = {jun},
pages = {425–435},
numpages = {11},
keywords = {Blame, gradual typing, lambda calculus}
}

    @article{10.1016/0167-6423(94)00004-2,
    author = {Henglein, Fritz},
    title = {Dynamic Typing: Syntax and Proof Theory},
    year = {1994},
    issue_date = {June 1994},
    publisher = {Elsevier North-Holland, Inc.},
    address = {USA},
    volume = {22},
    number = {3},
    issn = {0167-6423},
    url = {https://doi.org/10.1016/0167-6423(94)00004-2},
    doi = {10.1016/0167-6423(94)00004-2},
    journal = {Sci. Comput. Program.},
    month = {jun},
    pages = {197–230},
    numpages = {34}
    }

@article{10.1007/s10990-011-9066-z,
author = {Herman, David and Tomb, Aaron and Flanagan, Cormac},
title = {Space-Efficient Gradual Typing},
year = {2010},
issue_date = {June      2010},
publisher = {Kluwer Academic Publishers},
address = {USA},
volume = {23},
number = {2},
issn = {1388-3690},
url = {https://doi.org/10.1007/s10990-011-9066-z},
doi = {10.1007/s10990-011-9066-z},
abstract = {Gradual type systems offer a smooth continuum between static and dynamic typing by permitting the free mixture of typed and untyped code. The runtime systems for these languages, and other languages with hybrid type checking, typically enforce function types by dynamically generating function proxies. This approach can result in unbounded growth in the number of proxies, however, which drastically impacts space efficiency and destroys tail recursion.We present a semantics for gradual typing that is based on coercions instead of function proxies, and which combines adjacent coercions at runtime to limit their space consumption. We prove bounds on the space consumed by coercions as well as soundness of the type system, demonstrating that programmers can safely mix typing disciplines without incurring unreasonable overheads. Our approach also detects certain errors earlier than prior work.},
journal = {Higher Order Symbol. Comput.},
month = {jun},
pages = {167–189},
numpages = {23},
keywords = {Coercions, Type dynamic, Gradual typing, Casts}
}


@incollection{MARTINLOUF197581,
title = {About Models for Intuitionistic Type Theories and the Notion of Definitional Equality},
editor = {Stig Kanger},
series = {Studies in Logic and the Foundations of Mathematics},
publisher = {Elsevier},
volume = {82},
pages = {81-109},
year = {1975},
booktitle = {Proceedings of the Third Scandinavian Logic Symposium},
issn = {0049-237X},
doi = {https://doi.org/10.1016/S0049-237X(08)70727-4},
url = {https://www.sciencedirect.com/science/article/pii/S0049237X08707274},
author = {Per Martin-Löuf},
abstract = {Publisher Summary
This chapter is devoted to the formulation of the most natural notion of model for intuitionistic theories that either are type theories by their very definition or may be viewed as such because of the correspondence between formulae and type symbols. The chapter analyzes the notion of definitional equality and its formal counterpart, convertibility, and advocates a change in the current definition of convertibility for systems in which explicit definitions are represented by means of lambda abstraction rather than the introduction of constants or the special constants called combinators. Because of the correspondence between lambda terms and natural deductions, this change is equally called for in Prawitz's definition of convertibility for natural deductions. The chapter also outlines that the transition to intuitionistic abstractions on the metalevel is essential and nontrivial; essential, because they are the most fruitful notion of model, the interpretation of the convertibility relation conv, is standard, that is, it is interpreted as definitional equality in the model, and definitional equality is a notion that is unmentionable within the classical set theoretic framework.}
}

@article{WRIGHT199438,
title = {A Syntactic Approach to Type Soundness},
journal = {Information and Computation},
volume = {115},
number = {1},
pages = {38-94},
year = {1994},
issn = {0890-5401},
doi = {https://doi.org/10.1006/inco.1994.1093},
url = {https://www.sciencedirect.com/science/article/pii/S0890540184710935},
author = {A.K. Wright and M. Felleisen},
abstract = {We present a new approach to proving type soundness for Hindley/Milner-style polymorphic type systems. The keys to our approach are (1) an adaptation of subject reduction theorems from combinatory logic to programming languages, and (2) the use of rewriting techniques for the specification of the language semantics. The approach easily extends from polymorphic functional languages to imperative languages that provide references, exceptions, continuations, and similar features. We illustrate the technique with a type soundness theorem for the core of Standard ML, which includes the first type soundness proof for polymorphic exceptions and continuations.}
}

@article{hofmann1998groupoid,
  title={The groupoid interpretation of type theory},
  author={Hofmann, Martin and Streicher, Thomas},
  journal={Twenty-five years of constructive type theory (Venice, 1995)},
  volume={36},
  pages={83--111},
  year={1998},
  DOI = {https://doi.org/10.1093/oso/9780198501275.003.0008}
}

@phdthesis{streicher1993investigations,
  title={Investigations into intensional type theory},
  author={Streicher, Thomas},
  year={1993},
  school={Ludwig Maximilian Universit{\"a}t},
   note = {Habilitation thesis},
   url = {https://www2.mathematik.tu-darmstadt.de/~streicher/HabilStreicher.pdf}
}

@article{10.1145/3498693,
author = {Pujet, Lo\"{\i}c and Tabareau, Nicolas},
title = {Observational Equality: Now for Good},
year = {2022},
issue_date = {January 2022},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {6},
number = {POPL},
url = {https://doi.org/10.1145/3498693},
doi = {10.1145/3498693},
abstract = {Building on the recent extension of dependent type theory with a universe of definitionally proof-irrelevant types, we introduce TTobs, a new type theory based on the setoidal interpretation of dependent type theory. TTobs equips every type with an identity relation that satisfies function extensionality, propositional extensionality, and definitional uniqueness of identity proofs (UIP). Compared to other existing proposals to enrich dependent type theory with these principles, our theory features a notion of reduction that is normalizing and provides an algorithmic canonicity result, which we formally prove in Agda using the logical relation framework of Abel et al. Our paper thoroughly develops the meta-theoretical properties of TTobs, such as the decidability of the conversion and of the type checking, as well as consistency. We also explain how to extend our theory with quotient types, and we introduce a setoidal version of Swan's Id types that turn it into a proper extension of MLTT with inductive equality.},
journal = {Proc. ACM Program. Lang.},
month = {jan},
articleno = {32},
numpages = {27},
keywords = {rewriting theory, termination, confluence, type theory, dependent types}
}

@InProceedings{10.1007/978-3-642-00590-9_2,
author="Siek, Jeremy
and Garcia, Ronald
and Taha, Walid",
editor="Castagna, Giuseppe",
title="Exploring the Design Space of Higher-Order Casts",
booktitle="Programming Languages and Systems",
year="2009",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="17--31",
abstract="This paper explores the surprisingly rich design space for the simply typed lambda calculus with casts and a dynamic type. Such a calculus is the target intermediate language of the gradually typed lambda calculus but it is also interesting in its own right. In light of diverse requirements for casts, we develop a modular semantic framework, based on Henglein's Coercion Calculus, that instantiates a number of space-efficient, blame-tracking calculi, varying in what errors they detect and how they assign blame. Several of the resulting calculi extend work from the literature with either blame tracking or space efficiency, and in doing so reveal previously unknown connections. Furthermore, we introduce a new strategy for assigning blame under which casts that respect traditional subtyping are statically guaranteed to never fail. One particularly appealing outcome of this work is a novel cast calculus that is well-suited to gradual typing.",
isbn="978-3-642-00590-9"
}

@article{rgtt,
  TITLE = {{A Reasonably Gradual Type Theory}},
  AUTHOR = {Maillard, Kenji and Lennon-Bertrand, Meven and Tabareau, Nicolas and Tanter, {\'E}ric},
year = {2022},
issue_date = {August 2022},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {6},
number = {ICFP},
url = {https://doi.org/10.1145/3547655},
doi = {10.1145/3547655},
journal = {Proc. ACM Program. Lang.},
note = {Preprint: \url{https://hal.inria.fr/hal-03596652/}}
}



@unpublished{rgtt,
  NOTE = {To appear at ICFP 2022},
  YEAR = {2022},
  MONTH = Mar,
  PDF = {https://hal.inria.fr/hal-03596652/file/main.pdf},
  HAL_ID = {hal-03596652},
  HAL_VERSION = {v1},
}

@article{parameterizedCast,
  title={Parameterized cast calculi and reusable meta-theory for gradually typed lambda calculi},
  volume={31},
  DOI={10.1017/S0956796821000241},
  journal={Journal of Functional Programming},
  publisher={Cambridge University Press},
  author={Siek, Jeremy G. and Chen, Tianyu},
  year={2021},
  pages={e30}}


@misc{geq-arxiv,
  doi = {10.48550/ARXIV.2205.01241},

  url = {https://arxiv.org/abs/2205.01241},

  author = {Eremondi, Joseph and Garcia, Ronald and Tanter, Éric},

  keywords = {Programming Languages (cs.PL), FOS: Computer and information sciences, FOS: Computer and information sciences},

  title = {Propositional Equality for Gradual Dependently Typed Programming (Extended Technical Report)},

  publisher = {arXiv},

  year = {2022},

  copyright = {arXiv.org perpetual, non-exclusive license}
}


@article{KRAUS2023113843,
title = {Type-theoretic approaches to ordinals},
journal = {Theoretical Computer Science},
volume = {957},
pages = {113843},
year = {2023},
issn = {0304-3975},
doi = {https://doi.org/10.1016/j.tcs.2023.113843},
url = {https://www.sciencedirect.com/science/article/pii/S0304397523001561},
author = {Nicolai Kraus and Fredrik {Nordvall Forsberg} and Chuangjie Xu},
keywords = {Ordinal numbers, Constructive mathematics, Homotopy type theory, Cantor normal forms, Brouwer trees, Extensional well-founded orders},
abstract = {In a constructive setting, no concrete formulation of ordinal numbers can simultaneously have all the properties one might be interested in; for example, being able to calculate limits of sequences is constructively incompatible with deciding extensional equality. Using homotopy type theory as the foundational setting, we develop an abstract framework for ordinal theory and establish a collection of desirable properties and constructions. We then study and compare three concrete implementations of ordinals in homotopy type theory: first, a notation system based on Cantor normal forms (binary trees); second, a refined version of Brouwer trees (infinitely-branching trees); and third, extensional well-founded orders. Each of our three formulations has the central properties expected of ordinals, such as being equipped with an extensional and well-founded ordering as well as allowing basic arithmetic operations, but they differ with respect to what they make possible in addition. For example, for finite collections of ordinals, Cantor normal forms have decidable properties, but suprema of infinite collections cannot be computed. In contrast, extensional well-founded orders work well with infinite collections, but the price to pay is that almost all properties are undecidable. Brouwer trees, implemented as a quotient inductive-inductive type to ensure well-foundedness and extensionality, take the sweet spot in the middle by combining a restricted form of decidability with the ability to work with infinite increasing sequences. Our three approaches are connected by canonical order-preserving functions from the “more decidable” to the “less decidable” notions, i.e. from Cantor normal forms to Brouwer trees, and from there to extensional well-founded orders. We have formalised the results on Cantor normal forms and Brouwer trees in cubical Agda, while extensional well-founded orders have been studied and formalised thoroughly by Escardó and his collaborators. Finally, we compare the computational efficiency of our implementations with the results reported by Berger.}
}

@mastersthesis{Chan2022, series={Electronic Theses and Dissertations (ETDs) 2008+}, title={Sized dependent types via extensional type theory}, url={https://open.library.ubc.ca/collections/ubctheses/24/items/1.0416401}, DOI={http://dx.doi.org/10.14288/1.0416401}, school={University of British Columbia}, author={Chan, Jonathan H.W.}, year={2022}, collection={Electronic Theses and Dissertations (ETDs) 2008+}}

@article{BEZEM20221,
title = {Loop-checking and the uniform word problem for join-semilattices with an inflationary endomorphism},
journal = {Theoretical Computer Science},
volume = {913},
pages = {1-7},
year = {2022},
issn = {0304-3975},
doi = {https://doi.org/10.1016/j.tcs.2022.01.017},
url = {https://www.sciencedirect.com/science/article/pii/S0304397522000317},
author = {Marc Bezem and Thierry Coquand},
keywords = {Join-semilattices with one inflationary endomorphism, Uniform word problem, Loop-checking, Decidability},
abstract = {We solve in polynomial time two decision problems that occur in type checking when typings depend on universe level constraints.}
}


@techreport{corbyn:proof-synthesis,
  title={Proof Synthesis with Free Extensions in Intensional Type Theory},
  author={Corbyn, Nathan},
  year={2021},
  institution={University of Cambridge},
  note={{ME}ng Dissertation}
}

@misc{allais2023frex,
      title={Frex: dependently-typed algebraic simplification},
      author={Guillaume Allais and Edwin Brady and Nathan Corbyn and Ohad Kammar and Jeremy Yallop},
      year={2023},
      eprint={2306.15375},
      archivePrefix={arXiv},
      primaryClass={cs.PL}
}
